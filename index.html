<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>The Transport Layer Security (TLS) Protocol Version 1.3</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Requirements Terminology"/>
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Major Differences from TLS 1.2"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Goals"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Goals of This Document"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Presentation Language"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Basic Block Size"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Miscellaneous"/>
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Vectors"/>
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Numbers"/>
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 Enumerateds"/>
<link href="#rfc.section.4.6" rel="Chapter" title="4.6 Constructed Types"/>
<link href="#rfc.section.4.6.1" rel="Chapter" title="4.6.1 Variants"/>
<link href="#rfc.section.4.7" rel="Chapter" title="4.7 Cryptographic Attributes"/>
<link href="#rfc.section.4.8" rel="Chapter" title="4.8 Constants"/>
<link href="#rfc.section.5" rel="Chapter" title="5 The Pseudorandom Function"/>
<link href="#rfc.section.6" rel="Chapter" title="6 The TLS Record Protocol"/>
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Connection States"/>
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Record Layer"/>
<link href="#rfc.section.6.2.1" rel="Chapter" title="6.2.1 Fragmentation"/>
<link href="#rfc.section.6.2.2" rel="Chapter" title="6.2.2 Record Payload Protection"/>
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Key Calculation"/>
<link href="#rfc.section.7" rel="Chapter" title="7 The TLS Handshaking Protocols"/>
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Alert Protocol"/>
<link href="#rfc.section.7.1.1" rel="Chapter" title="7.1.1 Closure Alerts"/>
<link href="#rfc.section.7.1.2" rel="Chapter" title="7.1.2 Error Alerts"/>
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Handshake Protocol Overview"/>
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Handshake Protocol"/>
<link href="#rfc.section.7.3.1" rel="Chapter" title="7.3.1 Hello Messages"/>
<link href="#rfc.section.7.3.2" rel="Chapter" title="7.3.2 Client Key Share Message"/>
<link href="#rfc.section.7.3.3" rel="Chapter" title="7.3.3 Server Key Share Message"/>
<link href="#rfc.section.7.3.4" rel="Chapter" title="7.3.4 Encrypted Extensions"/>
<link href="#rfc.section.7.3.5" rel="Chapter" title="7.3.5 Server Certificate"/>
<link href="#rfc.section.7.3.6" rel="Chapter" title="7.3.6 Certificate Request"/>
<link href="#rfc.section.7.3.7" rel="Chapter" title="7.3.7 Server Certificate Verify"/>
<link href="#rfc.section.7.3.8" rel="Chapter" title="7.3.8 Server Finished"/>
<link href="#rfc.section.7.3.9" rel="Chapter" title="7.3.9 Client Certificate"/>
<link href="#rfc.section.7.3.10" rel="Chapter" title="7.3.10 Client Certificate Verify"/>
<link href="#rfc.section.8" rel="Chapter" title="8 Cryptographic Computations"/>
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Computing the Master Secret"/>
<link href="#rfc.section.8.1.1" rel="Chapter" title="8.1.1 The Session Hash"/>
<link href="#rfc.section.8.1.2" rel="Chapter" title="8.1.2 Diffie-Hellman"/>
<link href="#rfc.section.8.1.3" rel="Chapter" title="8.1.3 Elliptic Curve Diffie-Hellman"/>
<link href="#rfc.section.9" rel="Chapter" title="9 Mandatory Cipher Suites"/>
<link href="#rfc.section.10" rel="Chapter" title="10 Application Data Protocol"/>
<link href="#rfc.section.11" rel="Chapter" title="11 Security Considerations"/>
<link href="#rfc.section.12" rel="Chapter" title="12 IANA Considerations"/>
<link href="#rfc.references" rel="Chapter" title="13 References"/>
<link href="#rfc.references.1" rel="Chapter" title="13.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="13.2 Informative References"/>
<link href="#rfc.appendix.A" rel="Chapter" title="A Protocol Data Structures and Constant Values"/>
<link href="#rfc.appendix.A.1" rel="Chapter" title="A.1 Record Layer"/>
<link href="#rfc.appendix.A.2" rel="Chapter" title="A.2 Alert Messages"/>
<link href="#rfc.appendix.A.3" rel="Chapter" title="A.3 Handshake Protocol"/>
<link href="#rfc.appendix.A.3.1" rel="Chapter" title="A.3.1 Hello Messages"/>
<link href="#rfc.appendix.A.3.2" rel="Chapter" title="A.3.2 Key Exchange Messages"/>
<link href="#rfc.appendix.A.3.3" rel="Chapter" title="A.3.3 Authentication Messages"/>
<link href="#rfc.appendix.A.3.4" rel="Chapter" title="A.3.4 Handshake Finalization Messages"/>
<link href="#rfc.appendix.A.4" rel="Chapter" title="A.4 The Cipher Suite"/>
<link href="#rfc.appendix.A.5" rel="Chapter" title="A.5 The Security Parameters"/>
<link href="#rfc.appendix.A.6" rel="Chapter" title="A.6 Changes to RFC 4492"/>
<link href="#rfc.appendix.B" rel="Chapter" title="B Glossary"/>
<link href="#rfc.appendix.C" rel="Chapter" title="C Cipher Suite Definitions"/>
<link href="#rfc.appendix.D" rel="Chapter" title="D Implementation Notes"/>
<link href="#rfc.appendix.D.1" rel="Chapter" title="D.1 Random Number Generation and Seeding"/>
<link href="#rfc.appendix.D.2" rel="Chapter" title="D.2 Certificates and Authentication"/>
<link href="#rfc.appendix.D.3" rel="Chapter" title="D.3 Cipher Suites"/>
<link href="#rfc.appendix.D.4" rel="Chapter" title="D.4 Implementation Pitfalls"/>
<link href="#rfc.appendix.E" rel="Chapter" title="E Backward Compatibility"/>
<link href="#rfc.appendix.E.1" rel="Chapter" title="E.1 Compatibility with prior versions"/>
<link href="#rfc.appendix.E.2" rel="Chapter" title="E.2 Compatibility with SSL"/>
<link href="#rfc.appendix.F" rel="Chapter" title="F Security Analysis"/>
<link href="#rfc.appendix.F.1" rel="Chapter" title="F.1 Handshake Protocol"/>
<link href="#rfc.appendix.F.1.1" rel="Chapter" title="F.1.1 Authentication and Key Exchange"/>
<link href="#rfc.appendix.F.1.2" rel="Chapter" title="F.1.2 Version Rollback Attacks"/>
<link href="#rfc.appendix.F.1.3" rel="Chapter" title="F.1.3 Detecting Attacks Against the Handshake Protocol"/>
<link href="#rfc.appendix.F.1.4" rel="Chapter" title="F.1.4 Resuming Sessions"/>
<link href="#rfc.appendix.F.2" rel="Chapter" title="F.2 Protecting Application Data"/>
<link href="#rfc.appendix.F.3" rel="Chapter" title="F.3 Denial of Service"/>
<link href="#rfc.appendix.F.4" rel="Chapter" title="F.4 Final Notes"/>
<link href="#rfc.appendix.G" rel="Chapter" title="G Working Group Information"/>
<link href="#rfc.appendix.H" rel="Chapter" title="H Contributors"/>


  <meta name="generator" content="xml2rfc version 2.4.8 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Rescorla, E." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-tls-tls13-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2015-2-12" />
  <meta name="dct.abstract" content="This document specifies Version 1.3 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet. The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery." />
  <meta name="description" content="This document specifies Version 1.3 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet. The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">Network Working Group</td>
  <td class="right">E. Rescorla</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">RTFM, Inc.</td>
</tr>
<tr>
  <td class="left">Obsoletes: 3268, 4346, 4366, 5246 (if</td>
  <td class="right">February 12, 2015</td>
</tr>
<tr>
  <td class="left">           approved)</td>
  <td class="right"></td>
</tr>
<tr>
  <td class="left">Updates: 4492 (if approved)</td>
  <td class="right"></td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right"></td>
</tr>
<tr>
  <td class="left">Expires: August 16, 2015</td>
  <td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">The Transport Layer Security (TLS) Protocol Version 1.3<br />
  <span class="filename">draft-ietf-tls-tls13-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document specifies Version 1.3 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet. The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on August 16, 2015.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2015 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>
<p>This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008.  The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>1.1.   <a href="#rfc.section.1.1">Requirements Terminology</a></li>
<li>1.2.   <a href="#rfc.section.1.2">Major Differences from TLS 1.2</a></li>
<li>2.   <a href="#rfc.section.2">Goals</a></li>
<li>3.   <a href="#rfc.section.3">Goals of This Document</a></li>
<li>4.   <a href="#rfc.section.4">Presentation Language</a></li>
<li>4.1.   <a href="#rfc.section.4.1">Basic Block Size</a></li>
<li>4.2.   <a href="#rfc.section.4.2">Miscellaneous</a></li>
<li>4.3.   <a href="#rfc.section.4.3">Vectors</a></li>
<li>4.4.   <a href="#rfc.section.4.4">Numbers</a></li>
<li>4.5.   <a href="#rfc.section.4.5">Enumerateds</a></li>
<li>4.6.   <a href="#rfc.section.4.6">Constructed Types</a></li>
<li>4.6.1.   <a href="#rfc.section.4.6.1">Variants</a></li>
<li>4.7.   <a href="#rfc.section.4.7">Cryptographic Attributes</a></li>
<li>4.8.   <a href="#rfc.section.4.8">Constants</a></li>
<li>5.   <a href="#rfc.section.5">The Pseudorandom Function</a></li>
<li>6.   <a href="#rfc.section.6">The TLS Record Protocol</a></li>
<li>6.1.   <a href="#rfc.section.6.1">Connection States</a></li>
<li>6.2.   <a href="#rfc.section.6.2">Record Layer</a></li>
<li>6.2.1.   <a href="#rfc.section.6.2.1">Fragmentation</a></li>
<li>6.2.2.   <a href="#rfc.section.6.2.2">Record Payload Protection</a></li>
<li>6.3.   <a href="#rfc.section.6.3">Key Calculation</a></li>
<li>7.   <a href="#rfc.section.7">The TLS Handshaking Protocols</a></li>
<li>7.1.   <a href="#rfc.section.7.1">Alert Protocol</a></li>
<li>7.1.1.   <a href="#rfc.section.7.1.1">Closure Alerts</a></li>
<li>7.1.2.   <a href="#rfc.section.7.1.2">Error Alerts</a></li>
<li>7.2.   <a href="#rfc.section.7.2">Handshake Protocol Overview</a></li>
<li>7.3.   <a href="#rfc.section.7.3">Handshake Protocol</a></li>
<li>7.3.1.   <a href="#rfc.section.7.3.1">Hello Messages</a></li>
<li>7.3.2.   <a href="#rfc.section.7.3.2">Client Key Share Message</a></li>
<li>7.3.3.   <a href="#rfc.section.7.3.3">Server Key Share Message</a></li>
<li>7.3.4.   <a href="#rfc.section.7.3.4">Encrypted Extensions</a></li>
<li>7.3.5.   <a href="#rfc.section.7.3.5">Server Certificate</a></li>
<li>7.3.6.   <a href="#rfc.section.7.3.6">Certificate Request</a></li>
<li>7.3.7.   <a href="#rfc.section.7.3.7">Server Certificate Verify</a></li>
<li>7.3.8.   <a href="#rfc.section.7.3.8">Server Finished</a></li>
<li>7.3.9.   <a href="#rfc.section.7.3.9">Client Certificate</a></li>
<li>7.3.10.   <a href="#rfc.section.7.3.10">Client Certificate Verify</a></li>
<li>8.   <a href="#rfc.section.8">Cryptographic Computations</a></li>
<li>8.1.   <a href="#rfc.section.8.1">Computing the Master Secret</a></li>
<li>8.1.1.   <a href="#rfc.section.8.1.1">The Session Hash</a></li>
<li>8.1.2.   <a href="#rfc.section.8.1.2">Diffie-Hellman</a></li>
<li>8.1.3.   <a href="#rfc.section.8.1.3">Elliptic Curve Diffie-Hellman</a></li>
<li>9.   <a href="#rfc.section.9">Mandatory Cipher Suites</a></li>
<li>10.   <a href="#rfc.section.10">Application Data Protocol</a></li>
<li>11.   <a href="#rfc.section.11">Security Considerations</a></li>
<li>12.   <a href="#rfc.section.12">IANA Considerations</a></li>
<li>13.   <a href="#rfc.references">References</a></li>
<li>13.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>13.2.   <a href="#rfc.references.2">Informative References</a></li>
<li>Appendix A.   <a href="#rfc.appendix.A">Protocol Data Structures and Constant Values</a></li>
<li>A.1.   <a href="#rfc.appendix.A.1">Record Layer</a></li>
<li>A.2.   <a href="#rfc.appendix.A.2">Alert Messages</a></li>
<li>A.3.   <a href="#rfc.appendix.A.3">Handshake Protocol</a></li>
<li>A.3.1.   <a href="#rfc.appendix.A.3.1">Hello Messages</a></li>
<li>A.3.2.   <a href="#rfc.appendix.A.3.2">Key Exchange Messages</a></li>
<li>A.3.3.   <a href="#rfc.appendix.A.3.3">Authentication Messages</a></li>
<li>A.3.4.   <a href="#rfc.appendix.A.3.4">Handshake Finalization Messages</a></li>
<li>A.4.   <a href="#rfc.appendix.A.4">The Cipher Suite</a></li>
<li>A.5.   <a href="#rfc.appendix.A.5">The Security Parameters</a></li>
<li>A.6.   <a href="#rfc.appendix.A.6">Changes to RFC 4492</a></li>
<li>Appendix B.   <a href="#rfc.appendix.B">Glossary</a></li>
<li>Appendix C.   <a href="#rfc.appendix.C">Cipher Suite Definitions</a></li>
<li>Appendix D.   <a href="#rfc.appendix.D">Implementation Notes</a></li>
<li>D.1.   <a href="#rfc.appendix.D.1">Random Number Generation and Seeding</a></li>
<li>D.2.   <a href="#rfc.appendix.D.2">Certificates and Authentication</a></li>
<li>D.3.   <a href="#rfc.appendix.D.3">Cipher Suites</a></li>
<li>D.4.   <a href="#rfc.appendix.D.4">Implementation Pitfalls</a></li>
<li>Appendix E.   <a href="#rfc.appendix.E">Backward Compatibility</a></li>
<li>E.1.   <a href="#rfc.appendix.E.1">Compatibility with prior versions</a></li>
<li>E.2.   <a href="#rfc.appendix.E.2">Compatibility with SSL</a></li>
<li>Appendix F.   <a href="#rfc.appendix.F">Security Analysis</a></li>
<li>F.1.   <a href="#rfc.appendix.F.1">Handshake Protocol</a></li>
<li>F.1.1.   <a href="#rfc.appendix.F.1.1">Authentication and Key Exchange</a></li>
<li>F.1.2.   <a href="#rfc.appendix.F.1.2">Version Rollback Attacks</a></li>
<li>F.1.3.   <a href="#rfc.appendix.F.1.3">Detecting Attacks Against the Handshake Protocol</a></li>
<li>F.1.4.   <a href="#rfc.appendix.F.1.4">Resuming Sessions</a></li>
<li>F.2.   <a href="#rfc.appendix.F.2">Protecting Application Data</a></li>
<li>F.3.   <a href="#rfc.appendix.F.3">Denial of Service</a></li>
<li>F.4.   <a href="#rfc.appendix.F.4">Final Notes</a></li>
<li>Appendix G.   <a href="#rfc.appendix.G">Working Group Information</a></li>
<li>Appendix H.   <a href="#rfc.appendix.H">Contributors</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">DISCLAIMER: This is a WIP draft of TLS 1.3 and has not yet seen significant security analysis.</p>
<p id="rfc.section.1.p.2">RFC EDITOR: PLEASE REMOVE THE FOLLOWING PARAGRAPH The source for this draft is maintained in GitHub. Suggested changes should be submitted as pull requests at https://github.com/tlswg/tls13-spec. Instructions are on that page as well. Editorial changes can be managed in GitHub, but any substantive change should be discussed on the TLS mailing list.</p>
<p id="rfc.section.1.p.3">The primary goal of the TLS protocol is to provide privacy and data integrity between two communicating applications. The protocol is composed of two layers: the TLS Record Protocol and the TLS Handshake Protocol. At the lowest level, layered on top of some reliable transport protocol (e.g., TCP <a href="#RFC0793">[RFC0793]</a>), is the TLS Record Protocol. The TLS Record Protocol provides connection security that has two basic properties:</p>
<p/>

<ul>
  <li>The connection is private.  Symmetric cryptography is used for data encryption (e.g., AES <a href="#AES">[AES]</a>, etc.).  The keys for this symmetric encryption are generated uniquely for each connection and are based on a secret negotiated by another protocol (such as the TLS Handshake Protocol).  The Record Protocol can also be used without encryption, i.e., in integrity-only modes.</li>
  <li>The connection is reliable.  Messages include an authentication tag which protects them against modification.</li>
  <li>The Record Protocol can operate in an insecure mode but is generally only used in this mode while another protocol is using the Record Protocol as a transport for negotiating security parameters.</li>
</ul>
<p id="rfc.section.1.p.5">The TLS Record Protocol is used for encapsulation of various higher- level protocols. One such encapsulated protocol, the TLS Handshake Protocol, allows the server and client to authenticate each other and to negotiate an encryption algorithm and cryptographic keys before the application protocol transmits or receives its first byte of data. The TLS Handshake Protocol provides connection security that has three basic properties:</p>
<p/>

<ul>
  <li>The peer&#8217;s identity can be authenticated using asymmetric, or public key, cryptography (e.g., RSA <a href="#RSA">[RSA]</a>, DSA <a href="#DSS">[DSS]</a>, etc.).  This authentication can be made optional, but is generally required for at least one of the peers.</li>
  <li>The negotiation of a shared secret is secure: the negotiated secret is unavailable to eavesdroppers, and for any authenticated connection the secret cannot be obtained, even by an attacker who can place himself in the middle of the connection.</li>
  <li>The negotiation is reliable: no attacker can modify the negotiation communication without being detected by the parties to the communication.</li>
</ul>
<p id="rfc.section.1.p.7">One advantage of TLS is that it is application protocol independent.  Higher-level protocols can layer on top of the TLS protocol transparently. The TLS standard, however, does not specify how protocols add security with TLS; the decisions on how to initiate TLS handshaking and how to interpret the authentication certificates exchanged are left to the judgment of the designers and implementors of protocols that run on top of TLS.</p>
<h1 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#requirements-terminology" id="requirements-terminology">Requirements Terminology</a></h1>
<p id="rfc.section.1.1.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;NOT RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in RFC 2119 <a href="#RFC2119">[RFC2119]</a>.</p>
<h1 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2.</a> <a href="#major-differences-from-tls-12" id="major-differences-from-tls-12">Major Differences from TLS 1.2</a></h1>
<p id="rfc.section.1.2.p.1">draft-05</p>
<p/>

<ul>
  <li>Prohibit SSL negotiation for backwards compatibility.</li>
</ul>
<p id="rfc.section.1.2.p.3">draft-04</p>
<p/>

<ul>
  <li>Modify key computations to include session hash.</li>
  <li>Remove ChangeCipherSpec</li>
  <li>Renumber the new handshake messages to be somewhat more consistent with existing convention and to remove a duplicate registration.</li>
  <li>Remove renegotiation.</li>
  <li>Update format of signatures with context.</li>
  <li>Remove point format negotiation.</li>
</ul>
<p id="rfc.section.1.2.p.5">draft-03</p>
<p/>

<ul>
  <li>Remove GMT time.</li>
  <li>Merge in support for ECC from RFC 4492 but without explicit curves.</li>
  <li>Remove the unnecessary length field from the AD input to AEAD ciphers.</li>
  <li>Rename {Client,Server}KeyExchange to {Client,Server}KeyShare</li>
  <li>Add an explicit HelloRetryRequest to reject the client&#8217;s</li>
</ul>
<p id="rfc.section.1.2.p.7">draft-02</p>
<p/>

<ul>
  <li>Increment version number.</li>
  <li>Reworked handshake to provide 1-RTT mode.</li>
  <li>Remove custom DHE groups.</li>
  <li>Removed support for compression.</li>
  <li>Removed support for static RSA and DH key exchange.</li>
  <li>Removed support for non-AEAD ciphers</li>
</ul>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#goals" id="goals">Goals</a></h1>
<p id="rfc.section.2.p.1">The goals of the TLS protocol, in order of priority, are as follows:</p>
<p/>

<ol>
  <li>Cryptographic security: TLS should be used to establish a secure connection between two parties.</li>
  <li>Interoperability: Independent programmers should be able to develop applications utilizing TLS that can successfully exchange cryptographic parameters without knowledge of one another&#8217;s code.</li>
  <li>Extensibility: TLS seeks to provide a framework into which new public key and record protection methods can be incorporated as necessary. This will also accomplish two sub-goals: preventing the need to create a new protocol (and risking the introduction of possible new weaknesses) and avoiding the need to implement an entire new security library.</li>
  <li>Relative efficiency: Cryptographic operations tend to be highly CPU intensive, particularly public key operations. For this reason, the TLS protocol has incorporated an optional session caching scheme to reduce the number of connections that need to be established from scratch. Additionally, care has been taken to reduce network activity.</li>
</ol>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#goals-of-this-document" id="goals-of-this-document">Goals of This Document</a></h1>
<p id="rfc.section.3.p.1">This document and the TLS protocol itself are based on the SSL 3.0 Protocol Specification as published by Netscape. The differences between this protocol and SSL 3.0 are not dramatic, but they are significant enough that the various versions of TLS and SSL 3.0 do not interoperate (although each protocol incorporates a mechanism by which an implementation can back down to prior versions). This document is intended primarily for readers who will be implementing the protocol and for those doing cryptographic analysis of it. The specification has been written with this in mind, and it is intended to reflect the needs of those two groups. For that reason, many of the algorithm-dependent data structures and rules are included in the body of the text (as opposed to in an appendix), providing easier access to them.</p>
<p id="rfc.section.3.p.2">This document is not intended to supply any details of service definition or of interface definition, although it does cover select areas of policy as they are required for the maintenance of solid security.</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#presentation-language" id="presentation-language">Presentation Language</a></h1>
<p id="rfc.section.4.p.1">This document deals with the formatting of data in an external representation.  The following very basic and somewhat casually defined presentation syntax will be used. The syntax draws from several sources in its structure. Although it resembles the programming language &#8220;C&#8221; in its syntax and XDR <a href="#RFC4506">[RFC4506]</a> in both its syntax and intent, it would be risky to draw too many parallels. The purpose of this presentation language is to document TLS only; it has no general application beyond that particular goal.</p>
<h1 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#basic_block_size" id="basic_block_size">Basic Block Size</a></h1>
<p id="rfc.section.4.1.p.1">The representation of all data items is explicitly specified. The basic data block size is one byte (i.e., 8 bits). Multiple byte data items are concatenations of bytes, from left to right, from top to bottom. From the byte stream, a multi-byte item (a numeric in the example) is formed (using C notation) by:</p>
<pre>
   value = (byte[0] &lt;&lt; 8*(n-1)) | (byte[1] &lt;&lt; 8*(n-2)) |
           ... | byte[n-1];
</pre>
<p id="rfc.section.4.1.p.2">This byte ordering for multi-byte values is the commonplace network byte order or big-endian format.</p>
<h1 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> <a href="#miscellaneous" id="miscellaneous">Miscellaneous</a></h1>
<p id="rfc.section.4.2.p.1">Comments begin with &#8220;/*&#8221; and end with &#8220;*/&#8221;.</p>
<p id="rfc.section.4.2.p.2">Optional components are denoted by enclosing them in &#8220;[[ ]]&#8221; double brackets.</p>
<p id="rfc.section.4.2.p.3">Single-byte entities containing uninterpreted data are of type opaque.</p>
<h1 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a> <a href="#vectors" id="vectors">Vectors</a></h1>
<p id="rfc.section.4.3.p.1">A vector (single-dimensioned array) is a stream of homogeneous data elements.  The size of the vector may be specified at documentation time or left unspecified until runtime. In either case, the length declares the number of bytes, not the number of elements, in the vector. The syntax for specifying a new type, T&#8217;, that is a fixed- length vector of type T is</p>
<pre>
   T T'[n];
</pre>
<p id="rfc.section.4.3.p.2">Here, T&#8217; occupies n bytes in the data stream, where n is a multiple of the size of T.  The length of the vector is not included in the encoded stream.</p>
<p id="rfc.section.4.3.p.3">In the following example, Datum is defined to be three consecutive bytes that the protocol does not interpret, while Data is three consecutive Datum, consuming a total of nine bytes.</p>
<pre>
   opaque Datum[3];      /* three uninterpreted bytes */
   Datum Data[9];        /* 3 consecutive 3 byte vectors */
</pre>
<p id="rfc.section.4.3.p.4">Variable-length vectors are defined by specifying a subrange of legal lengths, inclusively, using the notation &lt;floor..ceiling&gt;. When these are encoded, the actual length precedes the vector&#8217;s contents in the byte stream. The length will be in the form of a number consuming as many bytes as required to hold the vector&#8217;s specified maximum (ceiling) length. A variable-length vector with an actual length field of zero is referred to as an empty vector.</p>
<pre>
   T T'&lt;floor..ceiling&gt;;
</pre>
<p id="rfc.section.4.3.p.5">In the following example, mandatory is a vector that must contain between 300 and 400 bytes of type opaque. It can never be empty. The actual length field consumes two bytes, a uint16, which is sufficient to represent the value 400 (see <a href="#numbers">Section 4.4</a>). On the other hand, longer can represent up to 800 bytes of data, or 400 uint16 elements, and it may be empty. Its encoding will include a two-byte actual length field prepended to the vector. The length of an encoded vector must be an even multiple of the length of a single element (for example, a 17-byte vector of uint16 would be illegal).</p>
<pre>
   opaque mandatory&lt;300..400&gt;;
         /* length field is 2 bytes, cannot be empty */
   uint16 longer&lt;0..800&gt;;
         /* zero to 400 16-bit unsigned integers */
</pre>
<h1 id="rfc.section.4.4"><a href="#rfc.section.4.4">4.4.</a> <a href="#numbers" id="numbers">Numbers</a></h1>
<p id="rfc.section.4.4.p.1">The basic numeric data type is an unsigned byte (uint8). All larger numeric data types are formed from fixed-length series of bytes concatenated as described in <a href="#basic_block_size">Section 4.1</a> and are also unsigned. The following numeric types are predefined.</p>
<pre>
   uint8 uint16[2];
   uint8 uint24[3];
   uint8 uint32[4];
   uint8 uint64[8];
</pre>
<p id="rfc.section.4.4.p.2">All values, here and elsewhere in the specification, are stored in network byte (big-endian) order; the uint32 represented by the hex bytes 01 02 03 04 is equivalent to the decimal value 16909060.</p>
<p id="rfc.section.4.4.p.3">Note that in some cases (e.g., DH parameters) it is necessary to represent integers as opaque vectors. In such cases, they are represented as unsigned integers (i.e., leading zero octets are not required even if the most significant bit is set).</p>
<h1 id="rfc.section.4.5"><a href="#rfc.section.4.5">4.5.</a> <a href="#enumerateds" id="enumerateds">Enumerateds</a></h1>
<p id="rfc.section.4.5.p.1">An additional sparse data type is available called enum. A field of type enum can only assume the values declared in the definition. Each definition is a different type. Only enumerateds of the same type may be assigned or compared.  Every element of an enumerated must be assigned a value, as demonstrated in the following example. Since the elements of the enumerated are not ordered, they can be assigned any unique value, in any order.</p>
<pre>
   enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;
</pre>
<p id="rfc.section.4.5.p.2">An enumerated occupies as much space in the byte stream as would its maximal defined ordinal value. The following definition would cause one byte to be used to carry fields of type Color.</p>
<pre>
   enum { red(3), blue(5), white(7) } Color;
</pre>
<p id="rfc.section.4.5.p.3">One may optionally specify a value without its associated tag to force the width definition without defining a superfluous element.</p>
<p id="rfc.section.4.5.p.4">In the following example, Taste will consume two bytes in the data stream but can only assume the values 1, 2, or 4.</p>
<pre>
   enum { sweet(1), sour(2), bitter(4), (32000) } Taste;
</pre>
<p id="rfc.section.4.5.p.5">The names of the elements of an enumeration are scoped within the defined type.  In the first example, a fully qualified reference to the second element of the enumeration would be Color.blue. Such qualification is not required if the target of the assignment is well specified.</p>
<pre>
   Color color = Color.blue;     /* overspecified, legal */
   Color color = blue;           /* correct, type implicit */
</pre>
<p id="rfc.section.4.5.p.6">For enumerateds that are never converted to external representation, the numerical information may be omitted.</p>
<pre>
   enum { low, medium, high } Amount;
</pre>
<h1 id="rfc.section.4.6"><a href="#rfc.section.4.6">4.6.</a> <a href="#constructed-types" id="constructed-types">Constructed Types</a></h1>
<p id="rfc.section.4.6.p.1">Structure types may be constructed from primitive types for convenience. Each specification declares a new, unique type. The syntax for definition is much like that of C.</p>
<pre>
   struct {
       T1 f1;
       T2 f2;
       ...
       Tn fn;
   } [[T]];
</pre>
<p id="rfc.section.4.6.p.2">The fields within a structure may be qualified using the type&#8217;s name, with a syntax much like that available for enumerateds. For example, T.f2 refers to the second field of the previous declaration. Structure definitions may be embedded.</p>
<h1 id="rfc.section.4.6.1"><a href="#rfc.section.4.6.1">4.6.1.</a> <a href="#variants" id="variants">Variants</a></h1>
<p id="rfc.section.4.6.1.p.1">Defined structures may have variants based on some knowledge that is available within the environment. The selector must be an enumerated type that defines the possible variants the structure defines. There must be a case arm for every element of the enumeration declared in the select. Case arms have limited fall-through: if two case arms follow in immediate succession with no fields in between, then they both contain the same fields. Thus, in the example below, &#8220;orange&#8221; and &#8220;banana&#8221; both contain V2. Note that this is a new piece of syntax in TLS 1.2.</p>
<p id="rfc.section.4.6.1.p.2">The body of the variant structure may be given a label for reference. The mechanism by which the variant is selected at runtime is not prescribed by the presentation language.</p>
<pre>
   struct {
       T1 f1;
       T2 f2;
       ....
       Tn fn;
        select (E) {
            case e1: Te1;
            case e2: Te2;
            case e3: case e4: Te3;
            ....
            case en: Ten;
        } [[fv]];
   } [[Tv]];
</pre>
<p id="rfc.section.4.6.1.p.3">For example:</p>
<pre>
   enum { apple, orange, banana } VariantTag;

   struct {
       uint16 number;
       opaque string&lt;0..10&gt;; /* variable length */
   } V1;

   struct {
       uint32 number;
       opaque string[10];    /* fixed length */
   } V2;

   struct {
       select (VariantTag) { /* value of selector is implicit */
           case apple:
             V1;   /* VariantBody, tag = apple */
           case orange:
           case banana:
             V2;   /* VariantBody, tag = orange or banana */
       } variant_body;       /* optional label on variant */
   } VariantRecord;
</pre>
<h1 id="rfc.section.4.7"><a href="#rfc.section.4.7">4.7.</a> <a href="#cryptographic-attributes" id="cryptographic-attributes">Cryptographic Attributes</a></h1>
<p id="rfc.section.4.7.p.1">The two cryptographic operations &#8212; digital signing, and authenticated encryption with additional data (AEAD) &#8212; are designated digitally-signed, and aead-ciphered, respectively. A field&#8217;s cryptographic processing is specified by prepending an appropriate key word designation before the field&#8217;s type specification.  Cryptographic keys are implied by the current session state (see <a href="#connection-states">Section 6.1</a>).</p>
<p id="rfc.section.4.7.p.2">A digitally-signed element is encoded as a struct DigitallySigned:</p>
<pre>
   struct {
      SignatureAndHashAlgorithm algorithm;
      opaque signature&lt;0..2^16-1&gt;;
   } DigitallySigned;
</pre>
<p id="rfc.section.4.7.p.3">The algorithm field specifies the algorithm used (see <a href="#signature-algorithms">Section 7.3.2.5.1</a> for the definition of this field). Note that the algorithm field was introduced in TLS 1.2, and is not in earlier versions. The signature is a digital signature using those algorithms over the contents of the element. The contents themselves do not appear on the wire but are simply calculated. The length of the signature is specified by the signing algorithm and key.</p>
<p id="rfc.section.4.7.p.4">In previous versions of TLS, the ServerKeyExchange format meant that attackers can obtain a signature of a message with a chosen, 32-byte prefix. Because TLS 1.3 servers are likely to also implement prior versions, the contents of the element always start with 64 bytes of octet 32 in order to clear that chosen-prefix.</p>
<p id="rfc.section.4.7.p.5">Following that padding is a NUL-terminated context string in order to disambiguate signatures for different purposes. The context string will be specified whenever a digitally-signed element is used.</p>
<p id="rfc.section.4.7.p.6">Finally, the specified contents of the digitally-signed structure follow the NUL at the end of the context string. (See the example at the end of this section.)</p>
<p id="rfc.section.4.7.p.7">In RSA signing, the opaque vector contains the signature generated using the RSASSA-PKCS1-v1_5 signature scheme defined in <a href="#RFC3447">[RFC3447]</a>. As discussed in <a href="#RFC3447">[RFC3447]</a>, the DigestInfo MUST be DER-encoded <a href="#X680">[X680]</a> <a href="#X690">[X690]</a>. For hash algorithms without parameters (which includes SHA-1), the DigestInfo.AlgorithmIdentifier.parameters field MUST be NULL, but implementations MUST accept both without parameters and with NULL parameters.  Note that earlier versions of TLS used a different RSA signature scheme that did not include a DigestInfo encoding.</p>
<p id="rfc.section.4.7.p.8">In DSA, the 20 bytes of the SHA-1 hash are run directly through the Digital Signing Algorithm with no additional hashing. This produces two values, r and s. The DSA signature is an opaque vector, as above, the contents of which are the DER encoding of:</p>
<pre>
   Dss-Sig-Value ::= SEQUENCE {
       r INTEGER,
       s INTEGER
   }
</pre>
<p id="rfc.section.4.7.p.9">Note: In current terminology, DSA refers to the Digital Signature Algorithm and DSS refers to the NIST standard. In the original SSL and TLS specs, &#8220;DSS&#8221; was used universally. This document uses &#8220;DSA&#8221; to refer to the algorithm, &#8220;DSS&#8221; to refer to the standard, and it uses &#8220;DSS&#8221; in the code point definitions for historical continuity.</p>
<p id="rfc.section.4.7.p.10">All ECDSA computations MUST be performed according to ANSI X9.62 <a href="#X962">[X962]</a> or its successors.  Data to be signed/verified is hashed, and the result run directly through the ECDSA algorithm with no additional hashing.  The default hash function is SHA-1 <a href="#SHS">[SHS]</a>.  However, an alternative hash function, such as one of the new SHA hash functions specified in FIPS 180-2 may be used instead if the certificate containing the EC public key explicitly requires use of another hash function.  (The mechanism for specifying the required hash function has not been standardized, but this provision anticipates such standardization and obviates the need to update this document in response.  Future PKIX RFCs may choose, for example, to specify the hash function to be used with a public key in the parameters field of subjectPublicKeyInfo.) [[OPEN ISSUE: This needs updating per 4492-bis https://github.com/tlswg/tls13-spec/issues/59]]</p>
<p id="rfc.section.4.7.p.11">In AEAD encryption, the plaintext is simultaneously encrypted and integrity protected. The input may be of any length, and aead-ciphered output is generally larger than the input in order to accommodate the integrity check value.</p>
<p id="rfc.section.4.7.p.12">In the following example</p>
<pre>
   struct {
       uint8 field1;
       uint8 field2;
       digitally-signed opaque {
         uint8 field3&lt;0..255&gt;;
         uint8 field4;
       };
   } UserType;
</pre>
<p id="rfc.section.4.7.p.13">Assume that the context string for the signature was specified as &#8220;Example&#8221;.  The input for the signature/hash algorithm would be:</p>
<pre>
   2020202020202020202020202020202020202020202020202020202020202020
   2020202020202020202020202020202020202020202020202020202020202020
   4578616d706c6500
</pre>
<p id="rfc.section.4.7.p.14">followed by the encoding of the inner struct (field3 and field4).</p>
<p id="rfc.section.4.7.p.15">The length of the structure, in bytes, would be equal to two bytes for field1 and field2, plus two bytes for the signature and hash algorithm, plus two bytes for the length of the signature, plus the length of the output of the signing algorithm. The length of the signature is known because the algorithm and key used for the signing are known prior to encoding or decoding this structure.</p>
<h1 id="rfc.section.4.8"><a href="#rfc.section.4.8">4.8.</a> <a href="#constants" id="constants">Constants</a></h1>
<p id="rfc.section.4.8.p.1">Typed constants can be defined for purposes of specification by declaring a symbol of the desired type and assigning values to it.</p>
<p id="rfc.section.4.8.p.2">Under-specified types (opaque, variable-length vectors, and structures that contain opaque) cannot be assigned values. No fields of a multi-element structure or vector may be elided.</p>
<p id="rfc.section.4.8.p.3">For example:</p>
<pre>
   struct {
       uint8 f1;
       uint8 f2;
   } Example1;

   Example1 ex1 = {1, 4};  /* assigns f1 = 1, f2 = 4 */
</pre>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#HMAC" id="HMAC">The Pseudorandom Function</a></h1>
<p id="rfc.section.5.p.1">A construction is required to do expansion of secrets into blocks of data for the purposes of key generation or validation. This pseudorandom function (PRF) takes as input a secret, a seed, and an identifying label and produces an output of arbitrary length.</p>
<p id="rfc.section.5.p.2">In this section, we define one PRF, based on HMAC <a href="#RFC2104">[RFC2104]</a>. This PRF with the SHA-256 hash function is used for all cipher suites defined in this document and in TLS documents published prior to this document when TLS 1.2 is negotiated. New cipher suites MUST explicitly specify a PRF and, in general, SHOULD use the TLS PRF with SHA-256 or a stronger standard hash function.</p>
<p id="rfc.section.5.p.3">First, we define a data expansion function, P_hash(secret, data), that uses a single hash function to expand a secret and seed into an arbitrary quantity of output:</p>
<pre>
   P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
                          HMAC_hash(secret, A(2) + seed) +
                          HMAC_hash(secret, A(3) + seed) + ...
</pre>
<p id="rfc.section.5.p.4">where + indicates concatenation.</p>
<p id="rfc.section.5.p.5">A() is defined as:</p>
<pre>
   A(0) = seed
   A(i) = HMAC_hash(secret, A(i-1))
</pre>
<p id="rfc.section.5.p.6">P_hash can be iterated as many times as necessary to produce the required quantity of data. For example, if P_SHA256 is being used to create 80 bytes of data, it will have to be iterated three times (through A(3)), creating 96 bytes of output data; the last 16 bytes of the final iteration will then be discarded, leaving 80 bytes of output data.</p>
<p id="rfc.section.5.p.7">TLS&#8217;s PRF is created by applying P_hash to the secret as:</p>
<pre>
   PRF(secret, label, seed) = P_&lt;hash&gt;(secret, label + seed)
</pre>
<p id="rfc.section.5.p.8">The label is an ASCII string.  It should be included in the exact form it is given without a length byte or trailing null character.  For example, the label &#8220;slithy toves&#8221; would be processed by hashing the following bytes:</p>
<pre>
   73 6C 69 74 68 79 20 74 6F 76 65 73
</pre>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#the-tls-record-protocol" id="the-tls-record-protocol">The TLS Record Protocol</a></h1>
<p id="rfc.section.6.p.1">The TLS Record Protocol is a layered protocol. At each layer, messages may include fields for length, description, and content. The Record Protocol takes messages to be transmitted, fragments the data into manageable blocks, protects the records, and transmits the result. Received data is decrypted and verified, reassembled, and then delivered to higher-level clients.</p>
<p id="rfc.section.6.p.2">Three protocols that use the record protocol are described in this document: the handshake protocol, the alert protocol, and the application data protocol. In order to allow extension of the TLS protocol, additional record content types can be supported by the record protocol. New record content type values are assigned by IANA in the TLS Content Type Registry as described in <a href="#iana-considerations">Section 12</a>.</p>
<p id="rfc.section.6.p.3">Implementations MUST NOT send record types not defined in this document unless negotiated by some extension. If a TLS implementation receives an unexpected record type, it MUST send an unexpected_message alert.</p>
<p id="rfc.section.6.p.4">Any protocol designed for use over TLS must be carefully designed to deal with all possible attacks against it. As a practical matter, this means that the protocol designer must be aware of what security properties TLS does and does not provide and cannot safely rely on the latter.</p>
<p id="rfc.section.6.p.5">Note in particular that type and length of a record are not protected by encryption. If this information is itself sensitive, application designers may wish to take steps (padding, cover traffic) to minimize information leakage.</p>
<h1 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> <a href="#connection-states" id="connection-states">Connection States</a></h1>
<p id="rfc.section.6.1.p.1">A TLS connection state is the operating environment of the TLS Record Protocol.  It specifies a record protection algorithm and its parameters as well as the record protection keys and IVs for the connection in both the read and the write directions. The security parameters are set by the TLS Handshake Protocol, which also determines when new cryptographic keys are installed and used for record protection.  The initial current state always specifies that records are not protected.</p>
<p id="rfc.section.6.1.p.2">The security parameters for a TLS Connection read and write state are set by providing the following values:</p>
<p/>

<dl>
  <dt>connection end</dt>
  <dd style="margin-left: 8"><br/> Whether this entity is considered the &#8220;client&#8221; or the &#8220;server&#8221; in this connection.</dd>
  <dt>PRF algorithm</dt>
  <dd style="margin-left: 8"><br/> An algorithm used to generate keys from the master secret (see <a href="#HMAC">Section 5</a> and <a href="#key-calculation">Section 6.3</a>).</dd>
  <dt>record protection algorithm</dt>
  <dd style="margin-left: 8"><br/> The algorithm to be used for record protection. This algorithm must be of the AEAD type and thus provides integrity and confidentiality as a single primitive. It is possible to have AEAD algorithms which do not provide any confidentiality and <a href="#record-payload-protection">Section 6.2.2</a> defines a special NULL_NULL AEAD algorithm for use in the initial handshake). This specification includes the key size of this algorithm and the lengths of explicit and implicit initialization vectors (or nonces).</dd>
  <dt>handshake master secret</dt>
  <dd style="margin-left: 8"><br/> A 48-byte secret shared between the two peers in the connection and used to generate keys for protecting the handshake.</dd>
  <dt>master secret</dt>
  <dd style="margin-left: 8"><br/> A 48-byte secret shared between the two peers in the connection and used to generate keys for protecting application data.</dd>
  <dt>client random</dt>
  <dd style="margin-left: 8"><br/> A 32-byte value provided by the client.</dd>
  <dt>server random</dt>
  <dd style="margin-left: 8"><br/> A 32-byte value provided by the server.</dd>
</dl>
<p id="rfc.section.6.1.p.4">These parameters are defined in the presentation language as:</p>
<pre>
   enum { server, client } ConnectionEnd;

   enum { tls_prf_sha256 } PRFAlgorithm;

   enum { aes_gcm } RecordProtAlgorithm;

   /* The algorithms specified in PRFAlgorithm and
      RecordProtAlgorithm may be added to. */

   struct {
       ConnectionEnd          entity;
       PRFAlgorithm           prf_algorithm;
       RecordProtAlgorithm    record_prot_algorithm;
       uint8                  enc_key_length;
       uint8                  block_length;
       uint8                  fixed_iv_length;
       uint8                  record_iv_length;
       opaque                 hs_master_secret[48];
       opaque                 master_secret[48];
       opaque                 client_random[32];
       opaque                 server_random[32];
   } SecurityParameters;
</pre>
<p id="rfc.section.6.1.p.5">The record layer will use the security parameters to generate the following four items (some of which are not required by all ciphers, and are thus empty):</p>
<pre>
   client write key
   server write key
   client write IV
   server write IV
</pre>
<p id="rfc.section.6.1.p.6">The client write parameters are used by the server when receiving and processing records and vice versa. The algorithm used for generating these items from the security parameters is described in <a href="#key-calculation">Section 6.3</a></p>
<p id="rfc.section.6.1.p.7">Once the security parameters have been set and the keys have been generated, the connection states can be instantiated by making them the current states.  These current states MUST be updated for each record processed. Each connection state includes the following elements:</p>
<p/>

<dl>
  <dt>cipher state</dt>
  <dd style="margin-left: 8"><br/> The current state of the encryption algorithm.  This will consist of the scheduled key for that connection.</dd>
  <dt>sequence number</dt>
  <dd style="margin-left: 8"><br/> Each connection state contains a sequence number, which is maintained separately for read and write states.  The sequence number MUST be set to zero whenever a connection state is made the active state.  Sequence numbers are of type uint64 and may not exceed 2^64-1.  Sequence numbers do not wrap.  If a TLS implementation would need to wrap a sequence number, it must terminate the connection.  A sequence number is incremented after each record: specifically, the first record transmitted under a particular connection state MUST use sequence number 0.</dd>
</dl>
<h1 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> <a href="#record-layer" id="record-layer">Record Layer</a></h1>
<p id="rfc.section.6.2.p.1">The TLS record layer receives uninterpreted data from higher layers in non-empty blocks of arbitrary size.</p>
<h1 id="rfc.section.6.2.1"><a href="#rfc.section.6.2.1">6.2.1.</a> <a href="#fragmentation" id="fragmentation">Fragmentation</a></h1>
<p id="rfc.section.6.2.1.p.1">The record layer fragments information blocks into TLSPlaintext records carrying data in chunks of 2^14 bytes or less. Client message boundaries are not preserved in the record layer (i.e., multiple client messages of the same ContentType MAY be coalesced into a single TLSPlaintext record, or a single message MAY be fragmented across several records).</p>
<pre>
   struct {
       uint8 major;
       uint8 minor;
   } ProtocolVersion;

   ProtocolVersion version = { 3, 4 };     /* TLS v1.3*/

   enum {
       reserved(20), alert(21), handshake(22),
       application_data(23), (255)
   } ContentType;

   struct {
       ContentType type;
       ProtocolVersion version;
       uint16 length;
       opaque fragment[TLSPlaintext.length];
   } TLSPlaintext;
</pre>
<p/>

<dl>
  <dt>type</dt>
  <dd style="margin-left: 8"><br/> The higher-level protocol used to process the enclosed fragment.</dd>
  <dt>version</dt>
  <dd style="margin-left: 8"><br/> The version of the protocol being employed.  This document describes TLS Version 1.3, which uses the version { 3, 4 }.  The version value 3.4 is historical, deriving from the use of {3, 1} for TLS 1.0.  (See <a href="#record-layer-1">Appendix A.1</a>.)  Note that a client that supports multiple versions of TLS may not know what version will be employed before it receives the ServerHello.  See <a href="#backward-compatibility">Appendix E</a> for discussion about what record layer version number should be employed for ClientHello.</dd>
  <dt>length</dt>
  <dd style="margin-left: 8"><br/> The length (in bytes) of the following TLSPlaintext.fragment.  The length MUST NOT exceed 2^14.</dd>
  <dt>fragment</dt>
  <dd style="margin-left: 8"><br/> The application data.  This data is transparent and treated as an independent block to be dealt with by the higher-level protocol specified by the type field.</dd>
</dl>
<p id="rfc.section.6.2.1.p.3">Implementations MUST NOT send zero-length fragments of Handshake or Alert types. Zero-length fragments of Application data MAY be sent as they are potentially useful as a traffic analysis countermeasure.</p>
<h1 id="rfc.section.6.2.2"><a href="#rfc.section.6.2.2">6.2.2.</a> <a href="#record-payload-protection" id="record-payload-protection">Record Payload Protection</a></h1>
<p id="rfc.section.6.2.2.p.1">The record protection functions translate a TLSPlaintext structure into a TLSCiphertext. The deprotection functions reverse the process. In TLS 1.3 as opposed to previous versions of TLS, all ciphers are modelled as &#8220;Authenticated Encryption with Additional Data&#8221; (AEAD) <a href="#RFC5116">[RFC5116]</a>.  AEAD functions provide a unified encryption and authentication operation which turns plaintext into authenticated ciphertext and back again.</p>
<p id="rfc.section.6.2.2.p.2">AEAD ciphers take as input a single key, a nonce, a plaintext, and &#8220;additional data&#8221; to be included in the authentication check, as described in Section 2.1 of <a href="#RFC5116">[RFC5116]</a>. The key is either the client_write_key or the server_write_key.</p>
<pre>
   struct {
       ContentType type;
       ProtocolVersion version;
       uint16 length;
       opaque nonce_explicit[SecurityParameters.record_iv_length];
       aead-ciphered struct {
          opaque content[TLSPlaintext.length];
       } fragment;
   } TLSCiphertext;
</pre>
<p/>

<dl>
  <dt>type</dt>
  <dd style="margin-left: 8"><br/> The type field is identical to TLSPlaintext.type.</dd>
  <dt>version</dt>
  <dd style="margin-left: 8"><br/> The version field is identical to TLSPlaintext.version.</dd>
  <dt>length</dt>
  <dd style="margin-left: 8"><br/> The length (in bytes) of the following TLSCiphertext.fragment.  The length MUST NOT exceed 2^14 + 2048.</dd>
  <dt>fragment</dt>
  <dd style="margin-left: 8"><br/> The AEAD encrypted form of TLSPlaintext.fragment.</dd>
</dl>
<p id="rfc.section.6.2.2.p.4">Each AEAD cipher suite MUST specify how the nonce supplied to the AEAD operation is constructed, and what is the length of the TLSCiphertext.nonce_explicit part. In many cases, it is appropriate to use the partially implicit nonce technique described in Section 3.2.1 of <a href="#RFC5116">[RFC5116]</a>; with record_iv_length being the length of the explicit part. In this case, the implicit part SHOULD be derived from key_block as client_write_iv and server_write_iv (as described in <a href="#key-calculation">Section 6.3</a>), and the explicit part is included in GenericAEAEDCipher.nonce_explicit.</p>
<p id="rfc.section.6.2.2.p.5">The plaintext is the TLSPlaintext.fragment.</p>
<p id="rfc.section.6.2.2.p.6">The additional authenticated data, which we denote as additional_data, is defined as follows:</p>
<pre>
   additional_data = seq_num + TLSPlaintext.type +
                     TLSPlaintext.version
</pre>
<p id="rfc.section.6.2.2.p.7">where &#8220;+&#8221; denotes concatenation.</p>
<p id="rfc.section.6.2.2.p.8">Note: In versions of TLS prior to 1.3, the additional_data included a length field. This presents a problem for cipher constructions with data-dependent padding (such as CBC). TLS 1.3 removes the length field and relies on the AEAD cipher to provide integrity for the length of the data.</p>
<p id="rfc.section.6.2.2.p.9">The AEAD output consists of the ciphertext output by the AEAD encryption operation. The length will generally be larger than TLSPlaintext.length, but by an amount that varies with the AEAD cipher. Since the ciphers might incorporate padding, the amount of overhead could vary with different TLSPlaintext.length values. Each AEAD cipher MUST NOT produce an expansion of greater than 1024 bytes. Symbolically,</p>
<pre>
   AEADEncrypted = AEAD-Encrypt(write_key, nonce, plaintext,
                                additional_data)
</pre>
<p id="rfc.section.6.2.2.p.10">[[OPEN ISSUE: Reduce these values? https://github.com/tlswg/tls13-spec/issues/55]]</p>
<p id="rfc.section.6.2.2.p.11">In order to decrypt and verify, the cipher takes as input the key, nonce, the &#8220;additional_data&#8221;, and the AEADEncrypted value. The output is either the plaintext or an error indicating that the decryption failed. There is no separate integrity check. That is:</p>
<pre>
   TLSPlaintext.fragment = AEAD-Decrypt(write_key, nonce,
                                        AEADEncrypted,
                                        additional_data)
</pre>
<p id="rfc.section.6.2.2.p.12">If the decryption fails, a fatal bad_record_mac alert MUST be generated.</p>
<p id="rfc.section.6.2.2.p.13">As a special case, we define the NULL_NULL AEAD cipher which is simply the identity operation and thus provides no security. This cipher MUST ONLY be used with the initial TLS_NULL_WITH_NULL_NULL cipher suite.</p>
<h1 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a> <a href="#key-calculation" id="key-calculation">Key Calculation</a></h1>
<p id="rfc.section.6.3.p.1">[[OPEN ISSUE: This needs to be revised. See https://github.com/tlswg/tls13-spec/issues/5]] The Record Protocol requires an algorithm to generate keys required by the current connection state (see <a href="#the-security-parameters">Appendix A.5</a>) from the security parameters provided by the handshake protocol.</p>
<p id="rfc.section.6.3.p.2">The master secret is expanded into a sequence of secure bytes, which is then split to a client write encryption key and a server write encryption key. Each of these is generated from the byte sequence in that order. Unused values are empty. Some ciphers may additionally require a client write IV and a server write IV.</p>
<p id="rfc.section.6.3.p.3">When keys are generated, the current master secret (MS) is used as an entropy source. For handshake records, this means the hs_master_secret. For application data records, this means the regular master_secret.</p>
<p id="rfc.section.6.3.p.4">To generate the key material, compute</p>
<pre>
   key_block = PRF(MS,
                   "key expansion",
                   SecurityParameters.server_random +
                   SecurityParameters.client_random);
</pre>
<p id="rfc.section.6.3.p.5">where MS is the relevant master secret. The PRF is computed enough times to generate the necessary amount of data for the key_block, which is then partitioned as follows:</p>
<pre>
   client_write_key[SecurityParameters.enc_key_length]
   server_write_key[SecurityParameters.enc_key_length]
   client_write_IV[SecurityParameters.fixed_iv_length]
   server_write_IV[SecurityParameters.fixed_iv_length]
</pre>
<p id="rfc.section.6.3.p.6">Currently, the client_write_IV and server_write_IV are only generated for implicit nonce techniques as described in Section 3.2.1 of <a href="#RFC5116">[RFC5116]</a>.</p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#the-tls-handshaking-protocols" id="the-tls-handshaking-protocols">The TLS Handshaking Protocols</a></h1>
<p id="rfc.section.7.p.1">TLS has three subprotocols that are used to allow peers to agree upon security parameters for the record layer, to authenticate themselves, to instantiate negotiated security parameters, and to report error conditions to each other.</p>
<p id="rfc.section.7.p.2">The Handshake Protocol is responsible for negotiating a session, which consists of the following items:</p>
<p/>

<dl>
  <dt>session identifier</dt>
  <dd style="margin-left: 8"><br/> An arbitrary byte sequence chosen by the server to identify an active or resumable session state.</dd>
  <dt>peer certificate</dt>
  <dd style="margin-left: 8"><br/> X509v3 <a href="#RFC3280">[RFC3280]</a> certificate of the peer.  This element of the state may be null.</dd>
  <dt>cipher spec</dt>
  <dd style="margin-left: 8"><br/> Specifies the authentication and key establishment algorithms, the pseudorandom function (PRF) used to generate keying material, and the record protection algorithm (See <a href="#the-security-parameters">Appendix A.5</a> for formal definition.)</dd>
  <dt>resumption premaster secret</dt>
  <dd style="margin-left: 8"><br/> 48-byte secret shared between the client and server.</dd>
  <dt>is resumable</dt>
  <dd style="margin-left: 8"><br/> A flag indicating whether the session can be used to initiate new connections.</dd>
</dl>
<p id="rfc.section.7.p.4">These items are then used to create security parameters for use by the record layer when protecting application data. Many connections can be instantiated using the same session through the resumption feature of the TLS Handshake Protocol.</p>
<h1 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a> <a href="#alert-protocol" id="alert-protocol">Alert Protocol</a></h1>
<p id="rfc.section.7.1.p.1">One of the content types supported by the TLS record layer is the alert type.  Alert messages convey the severity of the message (warning or fatal) and a description of the alert. Alert messages with a level of fatal result in the immediate termination of the connection. In this case, other connections corresponding to the session may continue, but the session identifier MUST be invalidated, preventing the failed session from being used to establish new connections. Like other messages, alert messages are encrypted as specified by the current connection state.</p>
<pre>
   enum { warning(1), fatal(2), (255) } AlertLevel;

   enum {
       close_notify(0),
       unexpected_message(10),
       bad_record_mac(20),
       decryption_failed_RESERVED(21),
       record_overflow(22),
       decompression_failure_RESERVED(30),
       handshake_failure(40),
       no_certificate_RESERVED(41),
       bad_certificate(42),
       unsupported_certificate(43),
       certificate_revoked(44),
       certificate_expired(45),
       certificate_unknown(46),
       illegal_parameter(47),
       unknown_ca(48),
       access_denied(49),
       decode_error(50),
       decrypt_error(51),
       export_restriction_RESERVED(60),
       protocol_version(70),
       insufficient_security(71),
       internal_error(80),
       user_canceled(90),
       no_renegotiation(100),
       unsupported_extension(110),
       (255)
   } AlertDescription;

   struct {
       AlertLevel level;
       AlertDescription description;
   } Alert;
</pre>
<h1 id="rfc.section.7.1.1"><a href="#rfc.section.7.1.1">7.1.1.</a> <a href="#closure-alerts" id="closure-alerts">Closure Alerts</a></h1>
<p id="rfc.section.7.1.1.p.1">The client and the server must share knowledge that the connection is ending in order to avoid a truncation attack. Either party may initiate the exchange of closing messages.</p>
<p/>

<dl>
  <dt>close_notify</dt>
  <dd style="margin-left: 8"><br/> This message notifies the recipient that the sender will not send any more messages on this connection.  Note that as of TLS 1.1, failure to properly close a connection no longer requires that a session not be resumed.  This is a change from TLS 1.0 to conform with widespread implementation practice.</dd>
</dl>
<p id="rfc.section.7.1.1.p.3">Either party MAY initiate a close by sending a close_notify alert. Any data received after a closure alert is ignored.</p>
<p id="rfc.section.7.1.1.p.4">Unless some other fatal alert has been transmitted, each party is required to send a close_notify alert before closing the write side of the connection. The other party MUST respond with a close_notify alert of its own and close down the connection immediately, discarding any pending writes. It is not required for the initiator of the close to wait for the responding close_notify alert before closing the read side of the connection.</p>
<p id="rfc.section.7.1.1.p.5">If the application protocol using TLS provides that any data may be carried over the underlying transport after the TLS connection is closed, the TLS implementation must receive the responding close_notify alert before indicating to the application layer that the TLS connection has ended. If the application protocol will not transfer any additional data, but will only close the underlying transport connection, then the implementation MAY choose to close the transport without waiting for the responding close_notify. No part of this standard should be taken to dictate the manner in which a usage profile for TLS manages its data transport, including when connections are opened or closed.</p>
<p id="rfc.section.7.1.1.p.6">Note: It is assumed that closing a connection reliably delivers pending data before destroying the transport.</p>
<h1 id="rfc.section.7.1.2"><a href="#rfc.section.7.1.2">7.1.2.</a> <a href="#error-alerts" id="error-alerts">Error Alerts</a></h1>
<p id="rfc.section.7.1.2.p.1">Error handling in the TLS Handshake protocol is very simple. When an error is detected, the detecting party sends a message to the other party. Upon transmission or receipt of a fatal alert message, both parties immediately close the connection. Servers and clients MUST forget any session-identifiers, keys, and secrets associated with a failed connection. Thus, any connection terminated with a fatal alert MUST NOT be resumed.</p>
<p id="rfc.section.7.1.2.p.2">Whenever an implementation encounters a condition which is defined as a fatal alert, it MUST send the appropriate alert prior to closing the connection. For all errors where an alert level is not explicitly specified, the sending party MAY determine at its discretion whether to treat this as a fatal error or not.  If the implementation chooses to send an alert but intends to close the connection immediately afterwards, it MUST send that alert at the fatal alert level.</p>
<p id="rfc.section.7.1.2.p.3">If an alert with a level of warning is sent and received, generally the connection can continue normally. If the receiving party decides not to proceed with the connection (e.g., after having received a no_renegotiation alert that it is not willing to accept), it SHOULD send a fatal alert to terminate the connection. Given this, the sending party cannot, in general, know how the receiving party will behave. Therefore, warning alerts are not very useful when the sending party wants to continue the connection, and thus are sometimes omitted. For example, if a peer decides to accept an expired certificate (perhaps after confirming this with the user) and wants to continue the connection, it would not generally send a certificate_expired alert.</p>
<p id="rfc.section.7.1.2.p.4">The following error alerts are defined:</p>
<p/>

<dl>
  <dt>unexpected_message</dt>
  <dd style="margin-left: 8"><br/> An inappropriate message was received.  This alert is always fatal and should never be observed in communication between proper implementations.</dd>
  <dt>bad_record_mac</dt>
  <dd style="margin-left: 8"><br/> This alert is returned if a record is received which cannot be deprotected. Because AEAD algorithms combine decryption and verification, this message is used for all deprotection failures.  This message is always fatal and should never be observed in communication between proper implementations (except when messages were corrupted in the network).</dd>
  <dt>decryption_failed_RESERVED</dt>
  <dd style="margin-left: 8"><br/> This alert was used in some earlier versions of TLS, and may have permitted certain attacks against the CBC mode <a href="#CBCATT">[CBCATT]</a>.  It MUST NOT be sent by compliant implementations.</dd>
  <dt>record_overflow</dt>
  <dd style="margin-left: 8"><br/> A TLSCiphertext record was received that had a length more than 2^14+2048 bytes, or a record decrypted to a TLSPlaintext record with more than 2^14 bytes.  This message is always fatal and should never be observed in communication between proper implementations (except when messages were corrupted in the network).</dd>
  <dt>decompression_failure</dt>
  <dd style="margin-left: 8"><br/> This alert was used in previous versions of TLS. TLS 1.3 does not include compression and TLS 1.3 implementations MUST NOT send this alert when in TLS 1.3 mode.</dd>
  <dt>handshake_failure</dt>
  <dd style="margin-left: 8"><br/> Reception of a handshake_failure alert message indicates that the sender was unable to negotiate an acceptable set of security parameters given the options available.  This is a fatal error.</dd>
  <dt>no_certificate_RESERVED</dt>
  <dd style="margin-left: 8"><br/> This alert was used in SSLv3 but not any version of TLS.  It MUST NOT be sent by compliant implementations.</dd>
  <dt>bad_certificate</dt>
  <dd style="margin-left: 8"><br/> A certificate was corrupt, contained signatures that did not verify correctly, etc.</dd>
  <dt>unsupported_certificate</dt>
  <dd style="margin-left: 8"><br/> A certificate was of an unsupported type.</dd>
  <dt>certificate_revoked</dt>
  <dd style="margin-left: 8"><br/> A certificate was revoked by its signer.</dd>
  <dt>certificate_expired</dt>
  <dd style="margin-left: 8"><br/> A certificate has expired or is not currently valid.</dd>
  <dt>certificate_unknown</dt>
  <dd style="margin-left: 8"><br/> Some other (unspecified) issue arose in processing the certificate, rendering it unacceptable.</dd>
  <dt>illegal_parameter</dt>
  <dd style="margin-left: 8"><br/> A field in the handshake was out of range or inconsistent with other fields.  This message is always fatal.</dd>
  <dt>unknown_ca</dt>
  <dd style="margin-left: 8"><br/> A valid certificate chain or partial chain was received, but the certificate was not accepted because the CA certificate could not be located or couldn&#8217;t be matched with a known, trusted CA.  This message is always fatal.</dd>
  <dt>access_denied</dt>
  <dd style="margin-left: 8"><br/> A valid certificate was received, but when access control was applied, the sender decided not to proceed with negotiation.  This message is always fatal.</dd>
  <dt>decode_error</dt>
  <dd style="margin-left: 8"><br/> A message could not be decoded because some field was out of the specified range or the length of the message was incorrect.  This message is always fatal and should never be observed in communication between proper implementations (except when messages were corrupted in the network).</dd>
  <dt>decrypt_error</dt>
  <dd style="margin-left: 8"><br/> A handshake cryptographic operation failed, including being unable to correctly verify a signature or validate a Finished message.  This message is always fatal.</dd>
  <dt>export_restriction_RESERVED</dt>
  <dd style="margin-left: 8"><br/> This alert was used in some earlier versions of TLS.  It MUST NOT be sent by compliant implementations.</dd>
  <dt>protocol_version</dt>
  <dd style="margin-left: 8"><br/> The protocol version the client has attempted to negotiate is recognized but not supported.  (For example, old protocol versions might be avoided for security reasons.)  This message is always fatal.</dd>
  <dt>insufficient_security</dt>
  <dd style="margin-left: 8"><br/> Returned instead of handshake_failure when a negotiation has failed specifically because the server requires ciphers more secure than those supported by the client.  This message is always fatal.</dd>
  <dt>internal_error</dt>
  <dd style="margin-left: 8"><br/> An internal error unrelated to the peer or the correctness of the protocol (such as a memory allocation failure) makes it impossible to continue.  This message is always fatal.</dd>
  <dt>user_canceled</dt>
  <dd style="margin-left: 8"><br/> This handshake is being canceled for some reason unrelated to a protocol failure.  If the user cancels an operation after the handshake is complete, just closing the connection by sending a close_notify is more appropriate.  This alert should be followed by a close_notify.  This message is generally a warning.</dd>
  <dt>no_renegotiation</dt>
  <dd style="margin-left: 8"><br/> Sent by the client in response to a hello request or by the server in response to a client hello after initial handshaking. Versions of TLS prior to TLS 1.3 supported renegotiation of a previously established connection; TLS 1.3 removes this feature. This message is always fatal.</dd>
  <dt>unsupported_extension</dt>
  <dd style="margin-left: 8"><br/> sent by clients that receive an extended server hello containing an extension that they did not put in the corresponding client hello.  This message is always fatal.</dd>
</dl>
<p id="rfc.section.7.1.2.p.6">New Alert values are assigned by IANA as described in <a href="#iana-considerations">Section 12</a>.</p>
<h1 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a> <a href="#handshake-protocol-overview" id="handshake-protocol-overview">Handshake Protocol Overview</a></h1>
<p id="rfc.section.7.2.p.1">The cryptographic parameters of the session state are produced by the TLS Handshake Protocol, which operates on top of the TLS record layer. When a TLS client and server first start communicating, they agree on a protocol version, select cryptographic algorithms, optionally authenticate each other, and use public-key encryption techniques to generate shared secrets.</p>
<p id="rfc.section.7.2.p.2">The TLS Handshake Protocol involves the following steps:</p>
<p/>

<ul>
  <li>Exchange hello messages to agree on a protocol version, algorithms, exchange random values, and check for session resumption.</li>
  <li>Exchange the necessary cryptographic parameters to allow the client and server to agree on a premaster secret.</li>
  <li>Exchange certificates and cryptographic information to allow the client and server to authenticate themselves.</li>
  <li>Generate a master secret from the premaster secret and exchanged random values.</li>
  <li>Provide security parameters to the record layer.</li>
  <li>Allow the client and server to verify that their peer has calculated the same security parameters and that the handshake occurred without tampering by an attacker.</li>
</ul>
<p id="rfc.section.7.2.p.4">Note that higher layers should not be overly reliant on whether TLS always negotiates the strongest possible connection between two peers. There are a number of ways in which a man-in-the-middle attacker can attempt to make two entities drop down to the least secure method they support. The protocol has been designed to minimize this risk, but there are still attacks available: for example, an attacker could block access to the port a secure service runs on, or attempt to get the peers to negotiate an unauthenticated connection. The fundamental rule is that higher levels must be cognizant of what their security requirements are and never transmit information over a channel less secure than what they require. The TLS protocol is secure in that any cipher suite offers its promised level of security: if you negotiate AES-GCM <a href="#GCM">[GCM]</a> with a 1024-bit DHE key exchange with a host whose certificate you have verified, you can expect to be that secure.</p>
<p id="rfc.section.7.2.p.5">These goals are achieved by the handshake protocol, which can be summarized as follows: The client sends a ClientHello message which contains a random nonce (ClientHello.random), its preferences for Protocol Version, Cipher Suite, and a variety of extensions. In the same flight, it sends a ClientKeyShare message which contains its share of the parameters for key agreement for some set of expected server parameters (DHE/ECDHE groups, etc.).</p>
<p id="rfc.section.7.2.p.6">If the client has provided a ClientKeyShare with an appropriate set of keying material, the server responds to the ClientHello with a ServerHello message. The ServerHello contains the server&#8217;s nonce (ServerHello.random), the server&#8217;s choice of the Protocol Version, Session ID and Cipher Suite, and the server&#8217;s response to the extensions the client offered.</p>
<p id="rfc.section.7.2.p.7">The server can then generate its own keying material share and send a ServerKeyShare message which contains its share of the parameters for the key agreement. The server can now compute the shared secret (the premaster secret). At this point, the server starts encrypting all remaining handshake traffic with the negotiated cipher suite using a key derived from the premaster secret (via the &#8220;handshake master secret&#8221;).  The remainder of the server&#8217;s handshake messages will be encrypted using that key.</p>
<p id="rfc.section.7.2.p.8">Following these messages, the server will send an EncryptedExtensions message which contains a response to any client&#8217;s extensions which are not necessary to establish the Cipher Suite. The server will then send its certificate in a Certificate message if it is to be authenticated.  The server may optionally request a certificate from the client by sending a CertificateRequest message at this point.  Finally, if the server is authenticated, it will send a CertificateVerify message which provides a signature over the entire handshake up to this point. This serves both to authenticate the server and to establish the integrity of the negotiation. Finally, the server sends a Finished message which includes an integrity check over the handshake keyed by the shared secret and demonstrates that the server and client have agreed upon the same keys.  [[TODO: If the server is not requesting client authentication, it MAY start sending application data following the Finished, though the server has no way of knowing who will be receiving the data. Add this.]]</p>
<p id="rfc.section.7.2.p.9">Once the client receives the ServerKeyShare, it can also compute the premaster secret and decrypt the server&#8217;s remaining handshake messages.  The client generates its own sending keys based on the premaster secret and will encrypt the remainder of its handshake messages using those keys and the newly established cipher suite.  If the server has sent a CertificateRequest message, the client MUST send the Certificate message, though it may contain zero certificates.  If the client has sent a certificate, a digitally-signed CertificateVerify message is sent to explicitly verify possession of the private key in the certificate.  Finally, the client sends the Finished message.</p>
<p id="rfc.section.7.2.p.10">At this point, the handshake is complete, and the client and server may exchange application layer data, which is protected using a new set of keys derived from both the premaster secret and the handshake transcript (see <a href="#I-D.ietf-tls-session-hash">[I-D.ietf-tls-session-hash]</a> for the security rationale for this.)</p>
<p id="rfc.section.7.2.p.11">Application data MUST NOT be sent prior to the Finished message.  [[TODO: can we make this clearer and more clearly match the text above about server-side False Start.]] Client                                               Server</p>
<pre>
   ClientHello
   ClientKeyShare            --------&gt;
                                                   ServerHello
                                                ServerKeyShare
                                        {EncryptedExtensions*}
                                                {Certificate*}
                                         {CertificateRequest*}
                                          {CertificateVerify*}
                             &lt;--------              {Finished}
   {Certificate*}
   {CertificateVerify*}
   {Finished}                --------&gt;
   [Application Data]        &lt;-------&gt;      [Application Data]


            Figure 1.  Message flow for a full handshake
</pre>
<p id="rfc.section.7.2.p.12">* Indicates optional or situation-dependent messages that are not always sent.</p>
<p id="rfc.section.7.2.p.13">{} Indicates messages protected using keys derived from the handshake master secret.</p>
<p id="rfc.section.7.2.p.14">[] Indicates messages protected using keys derived from the master secret.</p>
<p id="rfc.section.7.2.p.15">If the client has not provided an appropriate ClientKeyShare (e.g. it includes only DHE or ECDHE groups unacceptable or unsupported by the server), the server corrects the mismatch with a HelloRetryRequest and the client will need to restart the handshake with an appropriate ClientKeyShare, as shown in Figure 2:</p>
<pre>
   Client                                               Server

   ClientHello
   ClientKeyShare            --------&gt;
                             &lt;--------       HelloRetryRequest

   ClientHello
   ClientKeyShare            --------&gt;
                                                   ServerHello
                                                ServerKeyShare
                                        {EncryptedExtensions*}
                                                {Certificate*}
                                         {CertificateRequest*}
                                          {CertificateVerify*}
                             &lt;--------              {Finished}
   {Certificate*}
   {CertificateVerify*}
   {Finished}                --------&gt;
   [Application Data]        &lt;-------&gt;     [Application Data]
</pre>
<p id="rfc.section.7.2.p.16">Figure 2.  Message flow for a full handshake with mismatched parameters</p>
<p id="rfc.section.7.2.p.17">[[OPEN ISSUE: Should we restart the handshake hash? https://github.com/tlswg/tls13-spec/issues/104.]] [[OPEN ISSUE: We need to make sure that this flow doesn&#8217;t introduce downgrade issues. Potential options include continuing the handshake hashes (as long as clients don&#8217;t change their opinion of the server&#8217;s capabilities with aborted handshakes) and requiring the client to send the same ClientHello (as is currently done) and then checking you get the same negotiated parameters.]]</p>
<p id="rfc.section.7.2.p.18">If no common cryptographic parameters can be negotiated, the server will send a fatal alert.</p>
<p id="rfc.section.7.2.p.19">When the client and server decide to resume a previous session or duplicate an existing session (instead of negotiating new security parameters), the message flow is as follows:</p>
<p id="rfc.section.7.2.p.20">The client sends a ClientHello using the Session ID of the session to be resumed. The server then checks its session cache for a match. If a match is found, and the server is willing to re-establish the connection under the specified session state, it will send a ServerHello with the same Session ID value. At this point, both client and server MUST proceed directly to sending Finished messages, which are protected using handshake keys as described above, computed using resumption premaster secret created in the first handshake as the premaster secret. Once the re-establishment is complete, the client and server MAY begin to exchange application layer data, which is protected using the application secrets (See flow chart below.) If a Session ID match is not found, the server generates a new session ID, and the TLS client and server perform a full handshake.</p>
<pre>
   Client                                                Server

   ClientHello
   ClientKeyExhange              --------&gt;
                                                    ServerHello
                                 &lt;--------           {Finished}
   {Finished}                    --------&gt;
   [Application Data]            &lt;-------&gt;   [Application Data]

       Figure 3.  Message flow for an abbreviated handshake
</pre>
<p id="rfc.section.7.2.p.21">The contents and significance of each message will be presented in detail in the following sections.</p>
<h1 id="rfc.section.7.3"><a href="#rfc.section.7.3">7.3.</a> <a href="#handshake-protocol" id="handshake-protocol">Handshake Protocol</a></h1>
<p id="rfc.section.7.3.p.1">The TLS Handshake Protocol is one of the defined higher-level clients of the TLS Record Protocol. This protocol is used to negotiate the secure attributes of a session. Handshake messages are supplied to the TLS record layer, where they are encapsulated within one or more TLSPlaintext structures, which are processed and transmitted as specified by the current active session state.</p>
<pre>
   enum {
       reserved(0), client_hello(1), server_hello(2),
       client_key_share(5), hello_retry_request(6),
       server_key_share(7), certificate(11), reserved(12),
       certificate_request(13), certificate_verify(15),
       reserved(16), finished(20), (255)
   } HandshakeType;

   struct {
       HandshakeType msg_type;    /* handshake type */
       uint24 length;             /* bytes in message */
       select (HandshakeType) {
           case client_hello:        ClientHello;
           case client_key_share:    ClientKeyShare;
           case server_hello:        ServerHello;
           case hello_retry_request: HelloRetryRequest;
           case server_key_share:    ServerKeyShare;
           case certificate:         Certificate;
           case certificate_request: CertificateRequest;
           case certificate_verify:  CertificateVerify;
           case finished:            Finished;
       } body;
   } Handshake;
</pre>
<p id="rfc.section.7.3.p.2">The handshake protocol messages are presented below in the order they MUST be sent; sending handshake messages in an unexpected order results in a fatal error. Unneeded handshake messages can be omitted, however.</p>
<p id="rfc.section.7.3.p.3">New handshake message types are assigned by IANA as described in <a href="#iana-considerations">Section 12</a>.</p>
<h1 id="rfc.section.7.3.1"><a href="#rfc.section.7.3.1">7.3.1.</a> <a href="#hello-messages" id="hello-messages">Hello Messages</a></h1>
<p id="rfc.section.7.3.1.p.1">The hello phase messages are used to exchange security enhancement capabilities between the client and server. When a new session begins, the record layer&#8217;s connection state AEAD algorithm is initialized to NULL_NULL.</p>
<h1 id="rfc.section.7.3.1.1"><a href="#rfc.section.7.3.1.1">7.3.1.1.</a> <a href="#client-hello" id="client-hello">Client Hello</a></h1>
<p id="rfc.section.7.3.1.1.p.1">When this message will be sent:</p>
<p/>

<ul class="empty">
  <li>When a client first connects to a server, it is required to send the ClientHello as its first message. The client will also send a ClientHello when the server has responded to its ClientHello with a ServerHello that selects cryptographic parameters that don&#8217;t match the client&#8217;s ClientKeyShare. In that case, the client MUST send the same ClientHello (without modification) along with the new ClientKeyShare.  If a server receives a ClientHello at any other time, it MUST send a fatal no_renegotiation alert.</li>
</ul>
<p id="rfc.section.7.3.1.1.p.3">Structure of this message:</p>
<p/>

<ul class="empty">
  <li>The ClientHello message includes a random structure, which is used later in the protocol.</li>
</ul>
<pre>
      struct {
          opaque random_bytes[32];
      } Random;
</pre>
<p/>

<dl>
  <dt>random_bytes</dt>
  <dd style="margin-left: 8"><br/> 32 bytes generated by a secure random number generator.</dd>
</dl>
<p id="rfc.section.7.3.1.1.p.6">Note: Versions of TLS prior to TLS 1.3 used the top 32 bits of the Random value to encode the time since the UNIX epoch.</p>
<p id="rfc.section.7.3.1.1.p.7">Note: The ClientHello message includes a variable-length session identifier. If not empty, the value identifies a session between the same client and server whose security parameters the client wishes to reuse. The session identifier MAY be from an earlier connection, this connection, or from another currently active connection. The second option is useful if the client only wishes to update the random structures and derived values of a connection, and the third option makes it possible to establish several independent secure connections without repeating the full handshake protocol. These independent connections may occur sequentially or simultaneously; a SessionID becomes valid when the handshake negotiating it completes with the exchange of Finished messages and persists until it is removed due to aging or because a fatal error was encountered on a connection associated with the session. The actual contents of the SessionID are defined by the server.</p>
<pre>
   opaque SessionID&lt;0..32&gt;;
</pre>
<p id="rfc.section.7.3.1.1.p.8">Warning: Because the SessionID is transmitted without confidentiality or integrity protection, servers MUST NOT place confidential information in session identifiers or let the contents of fake session identifiers cause any breach of security. (Note that the content of the handshake as a whole, including the SessionID, is protected by the Finished messages exchanged at the end of the handshake.)</p>
<p id="rfc.section.7.3.1.1.p.9">The cipher suite list, passed from the client to the server in the ClientHello message, contains the combinations of cryptographic algorithms supported by the client in order of the client&#8217;s preference (favorite choice first). Each cipher suite defines a key exchange algorithm, a record protection algorithm (including secret key length) and a PRF. The server will select a cipher suite or, if no acceptable choices are presented, return a handshake failure alert and close the connection. If the list contains cipher suites the server does not recognize, support, or wish to use, the server MUST ignore those cipher suites, and process the remaining ones as usual.</p>
<pre>
   uint8 CipherSuite[2];    /* Cryptographic suite selector */

   enum { null(0), (255) } CompressionMethod;

   struct {
       ProtocolVersion client_version;
       Random random;
       SessionID session_id;
       CipherSuite cipher_suites&lt;2..2^16-2&gt;;
       CompressionMethod compression_methods&lt;1..2^8-1&gt;;
       select (extensions_present) {
           case false:
               struct {};
           case true:
               Extension extensions&lt;0..2^16-1&gt;;
       };
   } ClientHello;
</pre>
<p id="rfc.section.7.3.1.1.p.10">TLS allows extensions to follow the compression_methods field in an extensions block. The presence of extensions can be detected by determining whether there are bytes following the compression_methods at the end of the ClientHello. Note that this method of detecting optional data differs from the normal TLS method of having a variable-length field, but it is used for compatibility with TLS before extensions were defined.</p>
<p/>

<dl>
  <dt>client_version</dt>
  <dd style="margin-left: 8"><br/> The version of the TLS protocol by which the client wishes to communicate during this session.  This SHOULD be the latest (highest valued) version supported by the client.  For this version of the specification, the version will be 3.4 (see <a href="#backward-compatibility">Appendix E</a> for details about backward compatibility).</dd>
  <dt>random</dt>
  <dd style="margin-left: 8"><br/> A client-generated random structure.</dd>
  <dt>session_id</dt>
  <dd style="margin-left: 8"><br/> The ID of a session the client wishes to use for this connection.  This field is empty if no session_id is available, or if the client wishes to generate new security parameters.</dd>
  <dt>cipher_suites</dt>
  <dd style="margin-left: 8"><br/> This is a list of the cryptographic options supported by the client, with the client&#8217;s first preference first.  If the session_id field is not empty (implying a session resumption request), this vector MUST include at least the cipher_suite from that session.  Values are defined in <a href="#the-cipher-suite">Appendix A.4</a>.</dd>
  <dt>compression_methods</dt>
  <dd style="margin-left: 8"><br/> Versions of TLS before 1.3 supported compression and the list of compression methods was supplied in this field. For any TLS 1.3 ClientHello, this field MUST contain only the &#8220;null&#8221; compression method with the code point of 0. If a TLS 1.3 ClientHello is received with any other value in this field, the server MUST generate a fatal &#8220;illegal_parameter&#8221; alert. Note that TLS 1.3 servers may receive TLS 1.2 or prior ClientHellos which contain other compression methods and MUST follow the procedures for the appropriate prior version of TLS.</dd>
  <dt>extensions</dt>
  <dd style="margin-left: 8"><br/> Clients MAY request extended functionality from servers by sending data in the extensions field.  The actual &#8220;Extension&#8221; format is defined in <a href="#hello-extensions">Section 7.3.2.5</a>.</dd>
</dl>
<p id="rfc.section.7.3.1.1.p.12">In the event that a client requests additional functionality using extensions, and this functionality is not supplied by the server, the client MAY abort the handshake. A server MUST accept ClientHello messages both with and without the extensions field, and (as for all other messages) it MUST check that the amount of data in the message precisely matches one of these formats; if not, then it MUST send a fatal &#8220;decode_error&#8221; alert.</p>
<p id="rfc.section.7.3.1.1.p.13">After sending the ClientHello message, the client waits for a ServerHello or HelloRetryRequest message.</p>
<h1 id="rfc.section.7.3.2"><a href="#rfc.section.7.3.2">7.3.2.</a> <a href="#client-key-share-message" id="client-key-share-message">Client Key Share Message</a></h1>
<p id="rfc.section.7.3.2.p.1">When this message will be sent:</p>
<p/>

<ul class="empty">
  <li>This message is always sent by the client. It MUST immediately follow the ClientHello message. In backward compatibility mode (see Section XXX) it will be included in the EarlyData extension (<a href="#early-data-extension">Section 7.3.2.5.3</a>) in the ClientHello.</li>
</ul>
<p id="rfc.section.7.3.2.p.3">Meaning of this message:</p>
<p/>

<ul class="empty">
  <li>This message contains the client&#8217;s cryptographic parameters for zero or more key establishment methods.</li>
</ul>
<p id="rfc.section.7.3.2.p.5">Structure of this message:</p>
<pre>
   struct {
       NamedGroup group;
       opaque key_exchange&lt;1..2^16-1&gt;;
   } ClientKeyShareOffer;
</pre>
<p/>

<dl>
  <dt>group</dt>
  <dd style="margin-left: 8">The named group for the key share offer.  This identifies the specific key exchange method that the ClientKeyShareOffer describes.  Finite Field Diffie-Hellman parameters are described in <a href="#ffdhe-param">Section 7.3.2.1</a>; Elliptic Curve Diffie-Hellman parameters are described in <a href="#ecdhe-param">Section 7.3.2.2</a>.</dd>
  <dt>key_exchange</dt>
  <dd style="margin-left: 8">Key exchange information.  The contents of this field are determined by the value of NamedGroup entry and its corresponding definition.</dd>
</dl>
<pre>
   struct {
       ClientKeyShareOffer offers&lt;0..2^16-1&gt;;
   } ClientKeyShare;
</pre>
<p/>

<dl>
  <dt>offers</dt>
  <dd style="margin-left: 8"><br/> A list of ClientKeyShareOffer values.</dd>
</dl>
<p id="rfc.section.7.3.2.p.8">Clients may offer an arbitrary number of ClientKeyShareOffer values, each representing a single set of key agreement parameters; for instance a client might offer shares for several elliptic curves or multiple integer DH groups. The shares for each ClientKeyShareOffer MUST by generated independently. Clients MUST NOT offer multiple ClientKeyShareOffers for the same parameters. It is explicitly permitted to send an empty ClientKeyShare message, as this is used to elicit the server&#8217;s parameters if the client has no useful information.  [TODO: Recommendation about what the client offers. Presumably which integer DH groups and which curves.] [TODO: Work out how this interacts with PSK and SRP.]</p>
<h1 id="rfc.section.7.3.2.1"><a href="#rfc.section.7.3.2.1">7.3.2.1.</a> <a href="#ffdhe-param" id="ffdhe-param">Diffie-Hellman Parameters</a></h1>
<p id="rfc.section.7.3.2.1.p.1">Diffie-Hellman parameters for both clients and servers are encoded in the opaque key_exchange field of the ClientKeyShareOffer or ServerKeyShare structures. The opaque value contains the Diffie-Hellman public value (dh_Y = g^X mod p), encoded as a big-endian integer.</p>
<pre>
   opaque dh_Y&lt;1..2^16-1&gt;;
</pre>
<h1 id="rfc.section.7.3.2.2"><a href="#rfc.section.7.3.2.2">7.3.2.2.</a> <a href="#ecdhe-param" id="ecdhe-param">ECHDE Parameters</a></h1>
<p id="rfc.section.7.3.2.2.p.1">ECDHE parameters for both clients and servers are encoded in the opaque key_exchange field of the ClientKeyShareOffer or ServerKeyShare structures. The opaque value conveys the Elliptic Curve Diffie-Hellman public value (ecdh_Y) represented as a byte string ECPoint.point.</p>
<pre>
   opaque point &lt;1..2^8-1&gt;;
</pre>
<p/>

<dl>
  <dt>point</dt>
  <dd style="margin-left: 8"><br/> This is the byte string representation of an elliptic curve point following the conversion routine in Section 4.3.6 of ANSI X9.62 {{X962}.</dd>
</dl>
<p id="rfc.section.7.3.2.2.p.3">Although X9.62 supports multiple point formats, any given curve MUST specify only a single point format. All curves currently specified in this document MUST only be used with the uncompressed point format.</p>
<p id="rfc.section.7.3.2.2.p.4">Note: Versions of TLS prior to 1.3 permitted point negotiation; TLS 1.3 removes this feature in favor of a single point format for each curve.</p>
<p id="rfc.section.7.3.2.2.p.5">[[OPEN ISSUE: We will need to adjust the compressed/uncompressed point issue if we have new curves that don&#8217;t need point compression. This depends on the CFRG&#8217;s recommendations. The expectation is that future curves will come with defined point formats and that existing curves conform to X9.62.]]</p>
<h1 id="rfc.section.7.3.2.3"><a href="#rfc.section.7.3.2.3">7.3.2.3.</a> <a href="#server-hello" id="server-hello">Server Hello</a></h1>
<p id="rfc.section.7.3.2.3.p.1">When this message will be sent:</p>
<p/>

<ul class="empty">
  <li>The server will send this message in response to a ClientHello message when it was able to find an acceptable set of algorithms and the client&#8217;s ClientKeyShare message was acceptable. If the client proposed groups are not acceptable by the server, it will respond with an insufficient_security fatal alert.</li>
</ul>
<p id="rfc.section.7.3.2.3.p.3">Structure of this message:</p>
<pre>
   struct {
       ProtocolVersion server_version;
       Random random;
       SessionID session_id;
       CipherSuite cipher_suite;
       select (extensions_present) {
           case false:
               struct {};
           case true:
               Extension extensions&lt;0..2^16-1&gt;;
       };
   } ServerHello;
</pre>
<p id="rfc.section.7.3.2.3.p.4">The presence of extensions can be detected by determining whether there are bytes following the cipher_suite field at the end of the ServerHello.</p>
<p/>

<dl>
  <dt>server_version</dt>
  <dd style="margin-left: 8"><br/> This field will contain the lower of that suggested by the client in the client hello and the highest supported by the server.  For this version of the specification, the version is 3.4.  (See <a href="#backward-compatibility">Appendix E</a> for details about backward compatibility.)</dd>
  <dt>random</dt>
  <dd style="margin-left: 8"><br/> This structure is generated by the server and MUST be generated independently of the ClientHello.random.</dd>
  <dt>session_id</dt>
  <dd style="margin-left: 8"><br/> This is the identity of the session corresponding to this connection.  If the ClientHello.session_id was non-empty, the server will look in its session cache for a match.  If a match is found and the server is willing to establish the new connection using the specified session state, the server will respond with the same value as was supplied by the client.  This indicates a resumed session and dictates that the parties must proceed directly to the Finished messages.  Otherwise, this field will contain a different value identifying the new session.  The server may return an empty session_id to indicate that the session will not be cached and therefore cannot be resumed.  If a session is resumed, it must be resumed using the same cipher suite it was originally negotiated with.  Note that there is no requirement that the server resume any session even if it had formerly provided a session_id.  Clients MUST be prepared to do a full negotiation &#8212; including negotiating new cipher suites &#8212; during any handshake.</dd>
  <dt>cipher_suite</dt>
  <dd style="margin-left: 8"><br/> The single cipher suite selected by the server from the list in ClientHello.cipher_suites.  For resumed sessions, this field is the value from the state of the session being resumed.</dd>
  <dt>extensions</dt>
  <dd style="margin-left: 8"><br/> A list of extensions.  Note that only extensions offered by the client can appear in the server&#8217;s list. In TLS 1.3 as opposed to previous versions of TLS, the server&#8217;s extensions are split between the ServerHello and the EncryptedExtensions <a href="#encrypted-extensions">Section 7.3.4</a> message. The ServerHello MUST only include extensions which are required to establish the cryptographic context.</dd>
</dl>
<h1 id="rfc.section.7.3.2.4"><a href="#rfc.section.7.3.2.4">7.3.2.4.</a> <a href="#helloretryrequest" id="helloretryrequest">HelloRetryRequest</a></h1>
<p id="rfc.section.7.3.2.4.p.1">When this message will be sent:</p>
<p/>

<ul class="empty">
  <li>The server will send this message in response to a ClientHello message when it was able to find an acceptable set of algorithms but the client&#8217;s ClientKeyShare message did not contain an acceptable offer.  If it cannot find such a match, it will respond with a handshake failure alert.</li>
</ul>
<p id="rfc.section.7.3.2.4.p.3">Structure of this message:</p>
<pre>
   struct {
       ProtocolVersion server_version;
       CipherSuite cipher_suite;
       NamedGroup selected_group;
       Extension extensions&lt;0..2^16-1&gt;;
   } HelloRetryRequest;
</pre>
<p id="rfc.section.7.3.2.4.p.4">[[OPEN ISSUE: Merge in DTLS Cookies?]]</p>
<p/>

<dl>
  <dt>selected_group</dt>
  <dd style="margin-left: 8"><br/> The group which the client MUST use for its new ClientHello.</dd>
</dl>
<p id="rfc.section.7.3.2.4.p.6">The &#8220;server_version&#8221;, &#8220;cipher_suite&#8221; and &#8220;extensions&#8221; fields have the same meanings as their corresponding values in the ServerHello. The server SHOULD send only the extensions necessary for the client to generate a correct ClientHello/ClientKeyShare pair.</p>
<p id="rfc.section.7.3.2.4.p.7">Upon receipt of a HelloRetryRequest, the client MUST send a new ClientHello/ClientKeyShare pair to the server. The ClientKeyShare MUST contain both the groups in the original ClientKeyShare as well as a ClientKeyShareOffer consistent with the &#8220;selected_group&#8221; field.  I.e., it MUST be a superset of the previous ClientKeyShareOffer.</p>
<p id="rfc.section.7.3.2.4.p.8">Upon re-sending the ClientHello/ClientKeyShare and receiving the server&#8217;s ServerHello/ServerKeyShare, the client MUST verify that the selected ciphersuite and NamedGroup match that supplied in the HelloRetryRequest.</p>
<h1 id="rfc.section.7.3.2.5"><a href="#rfc.section.7.3.2.5">7.3.2.5.</a> <a href="#hello-extensions" id="hello-extensions">Hello Extensions</a></h1>
<p id="rfc.section.7.3.2.5.p.1">The extension format is:</p>
<pre>
   struct {
       ExtensionType extension_type;
       opaque extension_data&lt;0..2^16-1&gt;;
   } Extension;

   enum {
       signature_algorithms(13), early_data(TBD), (65535)
   } ExtensionType;
</pre>
<p id="rfc.section.7.3.2.5.p.2">Here:</p>
<p/>

<ul>
  <li>&#8220;extension_type&#8221; identifies the particular extension type.</li>
  <li>&#8220;extension_data&#8221; contains information specific to the particular extension type.</li>
</ul>
<p id="rfc.section.7.3.2.5.p.4">The initial set of extensions is defined in a companion document <a href="#TLSEXT">[TLSEXT]</a>.  The list of extension types is maintained by IANA as described in <a href="#iana-considerations">Section 12</a>.</p>
<p id="rfc.section.7.3.2.5.p.5">An extension type MUST NOT appear in the ServerHello unless the same extension type appeared in the corresponding ClientHello. If a client receives an extension type in ServerHello that it did not request in the associated ClientHello, it MUST abort the handshake with an unsupported_extension fatal alert.</p>
<p id="rfc.section.7.3.2.5.p.6">Nonetheless, &#8220;server-oriented&#8221; extensions may be provided in the future within this framework. Such an extension (say, of type x) would require the client to first send an extension of type x in a ClientHello with empty extension_data to indicate that it supports the extension type. In this case, the client is offering the capability to understand the extension type, and the server is taking the client up on its offer.</p>
<p id="rfc.section.7.3.2.5.p.7">When multiple extensions of different types are present in the ClientHello or ServerHello messages, the extensions MAY appear in any order. There MUST NOT be more than one extension of the same type.</p>
<p id="rfc.section.7.3.2.5.p.8">Finally, note that extensions can be sent both when starting a new session and when requesting session resumption. Indeed, a client that requests session resumption does not in general know whether the server will accept this request, and therefore it SHOULD send the same extensions as it would send if it were not attempting resumption.</p>
<p id="rfc.section.7.3.2.5.p.9">In general, the specification of each extension type needs to describe the effect of the extension both during full handshake and session resumption. Most current TLS extensions are relevant only when a session is initiated: when an older session is resumed, the server does not process these extensions in Client Hello, and does not include them in Server Hello. However, some extensions may specify different behavior during session resumption.</p>
<p id="rfc.section.7.3.2.5.p.10">There are subtle (and not so subtle) interactions that may occur in this protocol between new features and existing features which may result in a significant reduction in overall security. The following considerations should be taken into account when designing new extensions:</p>
<p/>

<ul>
  <li>Some cases where a server does not agree to an extension are error conditions, and some are simply refusals to support particular features. In general, error alerts should be used for the former, and a field in the server extension response for the latter.</li>
  <li>Extensions should, as far as possible, be designed to prevent any attack that forces use (or non-use) of a particular feature by manipulation of handshake messages. This principle should be followed regardless of whether the feature is believed to cause a security problem.  <br/><br/> Often the fact that the extension fields are included in the inputs to the Finished message hashes will be sufficient, but extreme care is needed when the extension changes the meaning of messages sent in the handshake phase.  Designers and implementors should be aware of the fact that until the handshake has been authenticated, active attackers can modify messages and insert, remove, or replace extensions.</li>
  <li>It would be technically possible to use extensions to change major aspects of the design of TLS; for example the design of cipher suite negotiation.  This is not recommended; it would be more appropriate to define a new version of TLS &#8212; particularly since the TLS handshake algorithms have specific protection against version rollback attacks based on the version number, and the possibility of version rollback should be a significant consideration in any major design change.</li>
</ul>
<h1 id="rfc.section.7.3.2.5.1"><a href="#rfc.section.7.3.2.5.1">7.3.2.5.1.</a> <a href="#signature-algorithms" id="signature-algorithms">Signature Algorithms</a></h1>
<p id="rfc.section.7.3.2.5.1.p.1">The client uses the &#8220;signature_algorithms&#8221; extension to indicate to the server which signature/hash algorithm pairs may be used in digital signatures. The &#8220;extension_data&#8221; field of this extension contains a &#8220;supported_signature_algorithms&#8221; value.</p>
<pre>
   enum {
       none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5),
       sha512(6), (255)
   } HashAlgorithm;

   enum { anonymous(0), rsa(1), dsa(2), ecdsa(3), (255) }
     SignatureAlgorithm;

   struct {
         HashAlgorithm hash;
         SignatureAlgorithm signature;
   } SignatureAndHashAlgorithm;

   SignatureAndHashAlgorithm
     supported_signature_algorithms&lt;2..2^16-2&gt;;
</pre>
<p id="rfc.section.7.3.2.5.1.p.2">Each SignatureAndHashAlgorithm value lists a single hash/signature pair that the client is willing to verify. The values are indicated in descending order of preference.</p>
<p id="rfc.section.7.3.2.5.1.p.3">Note: Because not all signature algorithms and hash algorithms may be accepted by an implementation (e.g., DSA with SHA-1, but not SHA-256), algorithms here are listed in pairs.</p>
<p/>

<dl>
  <dt>hash</dt>
  <dd style="margin-left: 8"><br/> This field indicates the hash algorithm which may be used.  The values indicate support for unhashed data, MD5 <a href="#RFC1321">[RFC1321]</a>, SHA-1, SHA-224, SHA-256, SHA-384, and SHA-512 <a href="#SHS">[SHS]</a>, respectively.  The &#8220;none&#8221; value is provided for future extensibility, in case of a signature algorithm which does not require hashing before signing.</dd>
  <dt>signature</dt>
  <dd style="margin-left: 8"><br/> This field indicates the signature algorithm that may be used.  The values indicate anonymous signatures, RSASSA-PKCS1-v1_5 <a href="#RFC3447">[RFC3447]</a> and DSA <a href="#DSS">[DSS]</a>, and ECDSA <a href="#ECDSA">[ECDSA]</a>, respectively.  The &#8220;anonymous&#8221; value is meaningless in this context but used in <a href="#server-key-share-message">Section 7.3.3</a>.  It MUST NOT appear in this extension.</dd>
</dl>
<p id="rfc.section.7.3.2.5.1.p.5">The semantics of this extension are somewhat complicated because the cipher suite indicates permissible signature algorithms but not hash algorithms.  <a href="#server-certificate">Section 7.3.5</a> and <a href="#server-key-share-message">Section 7.3.3</a> describe the appropriate rules.</p>
<p id="rfc.section.7.3.2.5.1.p.6">If the client supports only the default hash and signature algorithms (listed in this section), it MAY omit the signature_algorithms extension. If the client does not support the default algorithms, or supports other hash and signature algorithms (and it is willing to use them for verifying messages sent by the server, i.e., server certificates and server key share), it MUST send the signature_algorithms extension, listing the algorithms it is willing to accept.</p>
<p id="rfc.section.7.3.2.5.1.p.7">If the client does not send the signature_algorithms extension, the server MUST do the following:</p>
<p/>

<ul>
  <li>If the negotiated key exchange algorithm is one of (DHE_RSA, ECDHE_RSA), behave as if client had sent the value {sha1,rsa}.</li>
  <li>If the negotiated key exchange algorithm is DHE_DSS, behave as if the client had sent the value {sha1,dsa}.</li>
  <li>If the negotiated key exchange algorithm is ECDHE_ECDSA, behave as if the client had sent value {sha1,ecdsa}.</li>
</ul>
<p id="rfc.section.7.3.2.5.1.p.9">Note: this is a change from TLS 1.1 where there are no explicit rules, but as a practical matter one can assume that the peer supports MD5 and SHA-1.</p>
<p id="rfc.section.7.3.2.5.1.p.10">Note: this extension is not meaningful for TLS versions prior to 1.2. Clients MUST NOT offer it if they are offering prior versions. However, even if clients do offer it, the rules specified in <a href="#TLSEXT">[TLSEXT]</a> require servers to ignore extensions they do not understand.</p>
<p id="rfc.section.7.3.2.5.1.p.11">Servers MUST NOT send this extension. TLS servers MUST support receiving this extension.</p>
<p id="rfc.section.7.3.2.5.1.p.12">When performing session resumption, this extension is not included in Server Hello, and the server ignores the extension in Client Hello (if present).</p>
<h1 id="rfc.section.7.3.2.5.2"><a href="#rfc.section.7.3.2.5.2">7.3.2.5.2.</a> <a href="#negotiated-groups" id="negotiated-groups">Negotiated Groups</a></h1>
<p id="rfc.section.7.3.2.5.2.p.1">When sent by the client, the &#8220;supported_groups&#8221; extension indicates the named groups which the client supports, ordered from most preferred to least preferred.</p>
<p id="rfc.section.7.3.2.5.2.p.2">Note: In versions of TLS prior to TLS 1.3, this extension was named &#8220;elliptic curves&#8221; and only contained elliptic curve groups. See <a href="#RFC4492">[RFC4492]</a> and <a href="#I-D.ietf-tls-negotiated-ff-dhe">[I-D.ietf-tls-negotiated-ff-dhe]</a>.</p>
<p id="rfc.section.7.3.2.5.2.p.3">The &#8220;extension_data&#8221; field of this extension SHALL contain a &#8220;NamedGroupList&#8221; value:</p>
<pre>
    enum {
        // Elliptic Curve Groups.
        sect163k1 (1), sect163r1 (2), sect163r2 (3),
        sect193r1 (4), sect193r2 (5), sect233k1 (6),
        sect233r1 (7), sect239k1 (8), sect283k1 (9),
        sect283r1 (10), sect409k1 (11), sect409r1 (12),
        sect571k1 (13), sect571r1 (14), secp160k1 (15),
        secp160r1 (16), secp160r2 (17), secp192k1 (18),
        secp192r1 (19), secp224k1 (20), secp224r1 (21),
        secp256k1 (22), secp256r1 (23), secp384r1 (24),
        secp521r1 (25),

        // Finite Field Groups.
        ffdhe2048(256), ffdhe3072(257), ffdhe4096(258),
        ffdhe8192(259),

        // Reserved Code Points.
        reserved (0xFE00..0xFEFF),
        reserved(0xFF01),
        reserved(0xFF02),
        (0xFFFF)
    } NamedGroup;

    struct {
        NamedGroup named_group_list&lt;1..2^16-1&gt;
    } NamedGroupList;
</pre>
<p/>

<dl>
  <dt>sect163k1, etc</dt>
  <dd style="margin-left: 8"><br/> Indicates support of the corresponding named curve The named curves defined here are those specified in SEC 2 [13].  Note that many of these curves are also recommended in ANSI X9.62 <a href="#X962">[X962]</a> and FIPS 186-2 <a href="#DSS">[DSS]</a>.  Values 0xFE00 through 0xFEFF are reserved for private use.  Values 0xFF01 and 0xFF02 were used in previous versions of TLS but MUST NOT be offered by TLS 1.3 implementations.  [[OPEN ISSUE: Triage curve list.]]</dd>
  <dt>ffdhe2432, etc</dt>
  <dd style="margin-left: 8"><br/> Indicates support of the corresponding finite field group, defined in <a href="#I-D.ietf-tls-negotiated-ff-dhe">[I-D.ietf-tls-negotiated-ff-dhe]</a></dd>
</dl>
<p id="rfc.section.7.3.2.5.2.p.5">Items in named_curve_list are ordered according to the client&#8217;s preferences (favorite choice first).</p>
<p id="rfc.section.7.3.2.5.2.p.6">As an example, a client that only supports secp192r1 (aka NIST P-192; value 19 = 0x0013) and secp224r1 (aka NIST P-224; value 21 = 0x0015) and prefers to use secp192r1 would include a TLS extension consisting of the following octets.  Note that the first two octets indicate the extension type (Supported Group Extension):</p>
<pre>
    00 0A 00 06 00 04 00 13 00 15
</pre>
<p id="rfc.section.7.3.2.5.2.p.7">The client MUST supply a &#8220;named_groups&#8221; extension containing at least one group for each key exchange algorithm (currently DHE and ECDHE) for which it offers a cipher suite.  If the client does not supply a &#8220;named_groups&#8221; extension with a compatible group, the server MUST NOT negotiate a cipher suite of the relevant type.  For instance, if a client supplies only ECDHE groups, the server MUST NOT negotiate finite field Diffie-Hellman.  If no acceptable group can be selected across all cipher suites, then the server MUST generate a fatal &#8220;handshake_failure&#8221; alert.</p>
<p id="rfc.section.7.3.2.5.2.p.8">NOTE: A server participating in an ECDHE-ECDSA key exchange may use different curves for (i) the ECDSA key in its certificate, and (ii) the ephemeral ECDH key in the ServerKeyExchange message.  The server must consider the supported groups in both cases.</p>
<p id="rfc.section.7.3.2.5.2.p.9">[[TODO: IANA Considerations.]]</p>
<h1 id="rfc.section.7.3.2.5.3"><a href="#rfc.section.7.3.2.5.3">7.3.2.5.3.</a> <a href="#early-data-extension" id="early-data-extension">Early Data Extension</a></h1>
<p id="rfc.section.7.3.2.5.3.p.1">TLS versions before 1.3 have a strict message ordering and do not permit additional messages to follow the ClientHello. The EarlyData extension allows TLS messages which would otherwise be sent as separate records to be instead inserted in the ClientHello. The extension simply contains the TLS records which would otherwise have been included in the client&#8217;s first flight.</p>
<pre>
      struct {
        TLSCipherText messages&lt;5 .. 2^24-1&gt;;
      } EarlyDataExtension;
</pre>
<p id="rfc.section.7.3.2.5.3.p.2">Extra messages for the client&#8217;s first flight MAY either be transmitted standalone or sent as EarlyData. However, when a client does not know whether TLS 1.3 can be negotiated &#8211; e.g., because the server may support a prior version of TLS or because of network intermediaries &#8211; it SHOULD use the EarlyData extension. If the EarlyData extension is used, then clients MUST NOT send any messages other than the ClientHello in their initial flight.</p>
<p id="rfc.section.7.3.2.5.3.p.3">Any data included in EarlyData is not integrated into the handshake hashes directly. E.g., if the ClientKeyShare is included in EarlyData, then the handshake hashes consist of ClientHello + ServerHello, etc.  However, because the ClientKeyShare is in a ClientHello extension, it is still hashed transitively. This procedure guarantees that the Finished message covers these messages even if they are ultimately ignored by the server (e.g., because it is sent to a TLS 1.2 server). TLS 1.3 servers MUST understand messages sent in EarlyData, and aside from hashing them differently, MUST treat them as if they had been sent immediately after the ClientHello.</p>
<p id="rfc.section.7.3.2.5.3.p.4">Servers MUST NOT send the EarlyData extension. Negotiating TLS 1.3 serves as acknowledgement that it was processed as described above.</p>
<p id="rfc.section.7.3.2.5.3.p.5">[[OPEN ISSUE: This is a fairly general mechanism which is possibly overkill in the 1-RTT case, where it would potentially be more attractive to just have a &#8220;ClientKeyShare&#8221; extension. However, for the 0-RTT case we will want to send the Certificate, CertificateVerify, and application data, so a more general extension seems appropriate at least until we have determined we don&#8217;t need it for 0-RTT.]]</p>
<h1 id="rfc.section.7.3.3"><a href="#rfc.section.7.3.3">7.3.3.</a> <a href="#server-key-share-message" id="server-key-share-message">Server Key Share Message</a></h1>
<p id="rfc.section.7.3.3.p.1">When this message will be sent:</p>
<p/>

<ul class="empty">
  <li>This message will be sent immediately after the ServerHello message if the client has provided a ClientKeyShare message which is compatible with the selected cipher suite and group parameters.</li>
</ul>
<p id="rfc.section.7.3.3.p.3">Meaning of this message:</p>
<p/>

<ul class="empty">
  <li>This message conveys cryptographic information to allow the client to compute the premaster secret: a Diffie-Hellman public key with which the client can complete a key exchange (with the result being the premaster secret) or a public key for some other algorithm.</li>
</ul>
<p id="rfc.section.7.3.3.p.5">Structure of this message:</p>
<pre>
   struct {
     NamedGroup group;
     opaque key_exchange&lt;1..2^16-1&gt;;
   } ServerKeyShare;
</pre>
<p/>

<dl>
  <dt>group</dt>
  <dd style="margin-left: 8">The named group for the key share offer.  This identifies the selected key exchange method from the ClientKeyShare message (<a href="#client-key-share-message">Section 7.3.2</a>), identifying which value from the ClientKeyShareOffer the server has accepted as is responding to.</dd>
  <dt>key_exchange</dt>
  <dd style="margin-left: 8">Key exchange information.  The contents of this field are determined by the value of NamedGroup entry and its corresponding definition.</dd>
</dl>
<h1 id="rfc.section.7.3.4"><a href="#rfc.section.7.3.4">7.3.4.</a> <a href="#encrypted-extensions" id="encrypted-extensions">Encrypted Extensions</a></h1>
<p id="rfc.section.7.3.4.p.1">When this message will be sent:</p>
<p/>

<ul class="empty">
  <li>If this message is sent, it MUST be sent immediately after the server&#8217;s ServerKeyShare.</li>
</ul>
<p id="rfc.section.7.3.4.p.3">Meaning of this message:</p>
<p/>

<ul class="empty">
  <li>The EncryptedExtensions message simply contains any extensions which should be protected, i.e., any which are not needed to establish the cryptographic context. The same extension types MUST NOT appear in both the ServerHello and EncryptedExtensions.  If the same extension appears in both locations, the client MUST rely only on the value in the EncryptedExtensions block.  [[OPEN ISSUE: Should we just produce a canonical list of what goes where and have it be an error to have it in the wrong place? That seems simpler. Perhaps have a whitelist of which extensions can be unencrypted and everything else MUST be encrypted.]]</li>
</ul>
<p id="rfc.section.7.3.4.p.5">Structure of this message:</p>
<pre>
   struct {
       Extension extensions&lt;0..2^16-1&gt;;
   } EncryptedExtensions;
</pre>
<p/>

<dl>
  <dt>extensions</dt>
  <dd style="margin-left: 8"><br/> A list of extensions.</dd>
</dl>
<h1 id="rfc.section.7.3.5"><a href="#rfc.section.7.3.5">7.3.5.</a> <a href="#server-certificate" id="server-certificate">Server Certificate</a></h1>
<p id="rfc.section.7.3.5.p.1">When this message will be sent:</p>
<p/>

<ul class="empty">
  <li>The server MUST send a Certificate message whenever the agreed-upon key exchange method uses certificates for authentication (this includes all key exchange methods defined in this document except DH_anon). This message will always immediately follow either the EncryptedExtensions message if one is sent or the ServerKeyShare message.</li>
</ul>
<p id="rfc.section.7.3.5.p.3">Meaning of this message:</p>
<p/>

<ul class="empty">
  <li>This message conveys the server&#8217;s certificate chain to the client.</li>
</ul>
<p/>

<ul class="empty">
  <li>The certificate MUST be appropriate for the negotiated cipher suite&#8217;s key exchange algorithm and any negotiated extensions.</li>
</ul>
<p id="rfc.section.7.3.5.p.6">Structure of this message:</p>
<pre>
   opaque ASN1Cert&lt;1..2^24-1&gt;;

   struct {
       ASN1Cert certificate_list&lt;0..2^24-1&gt;;
   } Certificate;
</pre>
<p/>

<dl>
  <dt>certificate_list</dt>
  <dd style="margin-left: 8"><br/> This is a sequence (chain) of certificates.  The sender&#8217;s certificate MUST come first in the list.  Each following certificate MUST directly certify the one preceding it.  Because certificate validation requires that root keys be distributed independently, the self-signed certificate that specifies the root certificate authority MAY be omitted from the chain, under the assumption that the remote end must already possess it in order to validate it in any case.</dd>
</dl>
<p id="rfc.section.7.3.5.p.8">The same message type and structure will be used for the client&#8217;s response to a certificate request message. Note that a client MAY send no certificates if it does not have an appropriate certificate to send in response to the server&#8217;s authentication request.</p>
<p id="rfc.section.7.3.5.p.9">Note: PKCS #7 <a href="#PKCS7">[PKCS7]</a> is not used as the format for the certificate vector because PKCS #6 <a href="#PKCS6">[PKCS6]</a> extended certificates are not used. Also, PKCS #7 defines a SET rather than a SEQUENCE, making the task of parsing the list more difficult.</p>
<p id="rfc.section.7.3.5.p.10">The following rules apply to the certificates sent by the server:</p>
<p/>

<ul>
  <li>The certificate type MUST be X.509v3, unless explicitly negotiated otherwise (e.g., <a href="#RFC5081">[RFC5081]</a>).</li>
  <li>The end entity certificate&#8217;s public key (and associated restrictions) MUST be compatible with the selected key exchange algorithm.</li>
</ul>
<pre>
    Key Exchange Alg.  Certificate Key Type

    DHE_RSA            RSA public key; the certificate MUST allow the
    ECDHE_RSA          key to be used for signing (the
                       digitalSignature bit MUST be set if the key
                       usage extension is present) with the signature
                       scheme and hash algorithm that will be employed
                       in the server key exchange message.
                       Note: ECDHE_RSA is defined in [RFC4492].

    DHE_DSS            DSA public key; the certificate MUST allow the
                       key to be used for signing with the hash
                       algorithm that will be employed in the server
                       key exchange message.

    ECDHE_ECDSA        ECDSA-capable public key; the certificate MUST
                       allow the key to be used for signing with the
                       hash algorithm that will be employed in the
                       server key exchange message.  The public key
                       MUST use a curve and point format supported by
                       the client, as described in  [RFC4492].
</pre>
<p/>

<ul>
  <li>The &#8220;server_name&#8221; and &#8220;trusted_ca_keys&#8221; extensions <a href="#TLSEXT">[TLSEXT]</a> are used to guide certificate selection.</li>
</ul>
<p id="rfc.section.7.3.5.p.13">If the client provided a &#8220;signature_algorithms&#8221; extension, then all certificates provided by the server MUST be signed by a hash/signature algorithm pair that appears in that extension. Note that this implies that a certificate containing a key for one signature algorithm MAY be signed using a different signature algorithm (for instance, an RSA key signed with a DSA key).  This is a departure from TLS 1.1, which required that the algorithms be the same.</p>
<p id="rfc.section.7.3.5.p.14">If the server has multiple certificates, it chooses one of them based on the above-mentioned criteria (in addition to other criteria, such as transport layer endpoint, local configuration and preferences, etc.). If the server has a single certificate, it SHOULD attempt to validate that it meets these criteria.</p>
<p id="rfc.section.7.3.5.p.15">Note that there are certificates that use algorithms and/or algorithm combinations that cannot be currently used with TLS. For example, a certificate with RSASSA-PSS signature key (id-RSASSA-PSS OID in SubjectPublicKeyInfo) cannot be used because TLS defines no corresponding signature algorithm.</p>
<p id="rfc.section.7.3.5.p.16">As cipher suites that specify new key exchange methods are specified for the TLS protocol, they will imply the certificate format and the required encoded keying information.</p>
<h1 id="rfc.section.7.3.6"><a href="#rfc.section.7.3.6">7.3.6.</a> <a href="#certificate-request" id="certificate-request">Certificate Request</a></h1>
<p id="rfc.section.7.3.6.p.1">When this message will be sent:</p>
<p/>

<ul class="empty">
  <li>A non-anonymous server can optionally request a certificate from the client, if appropriate for the selected cipher suite. This message, if sent, will immediately follow the server&#8217;s Certificate message).</li>
</ul>
<p id="rfc.section.7.3.6.p.3">Structure of this message:</p>
<pre>
   enum {
       rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
       rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),
       fortezza_dms_RESERVED(20), (255)
   } ClientCertificateType;

   opaque DistinguishedName&lt;1..2^16-1&gt;;

   struct {
       ClientCertificateType certificate_types&lt;1..2^8-1&gt;;
       SignatureAndHashAlgorithm
         supported_signature_algorithms&lt;2..2^16-2&gt;;
       DistinguishedName certificate_authorities&lt;0..2^16-1&gt;;
   } CertificateRequest;
</pre>
<pre>
    rsa_sign        a certificate containing an RSA key
    dss_sign        a certificate containing a DSA key
    rsa_fixed_dh    a certificate containing a static DH key.
    dss_fixed_dh    a certificate containing a static DH key
</pre>
<p/>

<dl>
  <dt>certificate_types</dt>
  <dd style="margin-left: 8"><br/> A list of the types of certificate types that the client may offer.  </dd>
  <dt>supported_signature_algorithms</dt>
  <dd style="margin-left: 8"><br/> A list of the hash/signature algorithm pairs that the server is able to verify, listed in descending order of preference.</dd>
  <dt>certificate_authorities</dt>
  <dd style="margin-left: 8"><br/> A list of the distinguished names <a href="#X501">[X501]</a> of acceptable certificate_authorities, represented in DER-encoded format.  These distinguished names may specify a desired distinguished name for a root CA or for a subordinate CA; thus, this message can be used to describe known roots as well as a desired authorization space.  If the certificate_authorities list is empty, then the client MAY send any certificate of the appropriate ClientCertificateType, unless there is some external arrangement to the contrary.</dd>
</dl>
<p id="rfc.section.7.3.6.p.5">The interaction of the certificate_types and supported_signature_algorithms fields is somewhat complicated.  certificate_types has been present in TLS since SSLv3, but was somewhat underspecified.  Much of its functionality is superseded by supported_signature_algorithms.  The following rules apply:</p>
<p/>

<ul>
  <li>Any certificates provided by the client MUST be signed using a hash/signature algorithm pair found in supported_signature_algorithms.</li>
  <li>The end-entity certificate provided by the client MUST contain a key that is compatible with certificate_types.  If the key is a signature key, it MUST be usable with some hash/signature algorithm pair in supported_signature_algorithms.</li>
  <li>For historical reasons, the names of some client certificate types include the algorithm used to sign the certificate.  For example, in earlier versions of TLS, rsa_fixed_dh meant a certificate signed with RSA and containing a static DH key.  In TLS 1.2, this functionality has been obsoleted by the supported_signature_algorithms, and the certificate type no longer restricts the algorithm used to sign the certificate.  For example, if the server sends dss_fixed_dh certificate type and {{sha1, dsa}, {sha1, rsa}} signature types, the client MAY reply with a certificate containing a static DH key, signed with RSA- SHA1.</li>
</ul>
<p id="rfc.section.7.3.6.p.7">New ClientCertificateType values are assigned by IANA as described in <a href="#iana-considerations">Section 12</a>.</p>
<p id="rfc.section.7.3.6.p.8">Note: Values listed as RESERVED may not be used. They were used in SSLv3.</p>
<p id="rfc.section.7.3.6.p.9">Note: It is a fatal handshake_failure alert for an anonymous server to request client authentication.</p>
<h1 id="rfc.section.7.3.7"><a href="#rfc.section.7.3.7">7.3.7.</a> <a href="#server-certificate-verify" id="server-certificate-verify">Server Certificate Verify</a></h1>
<p id="rfc.section.7.3.7.p.1">When this message will be sent:</p>
<p/>

<ul class="empty">
  <li>This message is used to provide explicit proof that the server possesses the private key corresponding to its certificate.  certificate and also provides integrity for the handshake up to this point. This message is only sent when the server is authenticated via a certificate. When sent, it MUST be the last server handshake message prior to the Finished.</li>
</ul>
<p id="rfc.section.7.3.7.p.3">Structure of this message:</p>
<pre>
   struct {
        digitally-signed struct {
            opaque handshake_messages_hash[hash_length];
        }
   } CertificateVerify;
</pre>
<p/>

<ul class="empty">
  <li>Here handshake_messages_hash is a digest of all handshake messages sent or received, starting at ClientHello and up to, but not including, this message, including the type and length fields of the handshake messages. This is a digest of the concatenation of all the Handshake structures (as defined in <a href="#handshake-protocol">Section 7.3</a>) exchanged thus far. For the PRF defined in Section 5, the digest MUST be the Hash used as the basis for the PRF.  Any cipher suite which defines a different PRF MUST also define the Hash to use in this computation. Note that this is the same running hash that is used in the Finished message <a href="#server-finished">Section 7.3.8</a>.</li>
</ul>
<p/>

<ul class="empty">
  <li>The context string for the signature is &#8220;TLS 1.3, server CertificateVerify&#8221;. A hash of the handshake messages is signed rather than the messages themselves because the digitally-signed format requires padding and context bytes at the beginning of the input. Thus, by signing a digest of the messages, an implementation need only maintain one running hash per hash type for CertificateVerify, Finished and other messages.</li>
</ul>
<p/>

<ul class="empty">
  <li>If the client has offered the &#8220;signature_algorithms&#8221; extension, the signature algorithm and hash algorithm MUST be a pair listed in that extension. Note that there is a possibility for inconsistencies here. For instance, the client might offer DHE_DSS key exchange but omit any DSA pairs from its &#8220;signature_algorithms&#8221; extension. In order to negotiate correctly, the server MUST check any candidate cipher suites against the &#8220;signature_algorithms&#8221; extension before selecting them. This is somewhat inelegant but is a compromise designed to minimize changes to the original cipher suite design.</li>
</ul>
<p/>

<ul class="empty">
  <li>In addition, the hash and signature algorithms MUST be compatible with the key in the server&#8217;s end-entity certificate. RSA keys MAY be used with any permitted hash algorithm, subject to restrictions in the certificate, if any.</li>
</ul>
<p/>

<ul class="empty">
  <li>Because DSA signatures do not contain any secure indication of hash algorithm, there is a risk of hash substitution if multiple hashes may be used with any key. Currently, DSA <a href="#DSS">[DSS]</a> may only be used with SHA-1. Future revisions of DSS <a href="#DSS-3">[DSS-3]</a> are expected to allow the use of other digest algorithms with DSA, as well as guidance as to which digest algorithms should be used with each key size. In addition, future revisions of <a href="#RFC3280">[RFC3280]</a> may specify mechanisms for certificates to indicate which digest algorithms are to be used with DSA.  [[TODO: Update this to deal with DSS-3 and DSS-4.  https://github.com/tlswg/tls13-spec/issues/59]]</li>
</ul>
<h1 id="rfc.section.7.3.8"><a href="#rfc.section.7.3.8">7.3.8.</a> <a href="#server-finished" id="server-finished">Server Finished</a></h1>
<p id="rfc.section.7.3.8.p.1">When this message will be sent:</p>
<p/>

<ul class="empty">
  <li>The Server&#8217;s Finished message is the final message sent by the server and indicates that the key exchange and authentication processes were successful.</li>
</ul>
<p id="rfc.section.7.3.8.p.3">Meaning of this message:</p>
<p/>

<ul class="empty">
  <li>Recipients of Finished messages MUST verify that the contents are correct. Once a side has sent its Finished message and received and validated the Finished message from its peer, it may begin to send and receive application data over the connection. This data will be protected under keys derived from the hs_master_secret (see <a href="#cryptographic-computations">Section 8</a>.</li>
</ul>
<p id="rfc.section.7.3.8.p.5">Structure of this message:</p>
<pre>
   struct {
       opaque verify_data[verify_data_length];
   } Finished;
</pre>
<p/>

<dl>
  <dt>verify_data</dt>
  <dd style="margin-left: 8"><br/> PRF(hs_master_secret, finished_label, Hash(handshake_messages)) [0..verify_data_length-1];</dd>
  <dt>finished_label</dt>
  <dd style="margin-left: 8"><br/> For Finished messages sent by the client, the string &#8220;client finished&#8221;.  For Finished messages sent by the server, the string &#8220;server finished&#8221;.</dd>
</dl>
<p/>

<ul class="empty">
  <li>Hash denotes a Hash of the handshake messages. For the PRF defined in <a href="#HMAC">Section 5</a>, the Hash MUST be the Hash used as the basis for the PRF. Any cipher suite which defines a different PRF MUST also define the Hash to use in the Finished computation.</li>
</ul>
<p/>

<ul class="empty">
  <li>In previous versions of TLS, the verify_data was always 12 octets long. In the current version of TLS, it depends on the cipher suite. Any cipher suite which does not explicitly specify verify_data_length has a verify_data_length equal to 12. This includes all existing cipher suites. Note that this representation has the same encoding as with previous versions. Future cipher suites MAY specify other lengths but such length MUST be at least 12 bytes.</li>
</ul>
<p/>

<dl>
  <dt>handshake_messages</dt>
  <dd style="margin-left: 8"><br/> All of the data from all messages in this handshake (not including any HelloRequest messages) up to, but not including, this message.  This is only data visible at the handshake layer and does not include record layer headers.  This is the concatenation of all the Handshake structures as defined in <a href="#handshake-protocol">Section 7.3</a>, exchanged thus far.</dd>
</dl>
<p id="rfc.section.7.3.8.p.10">The value handshake_messages includes all handshake messages starting at ClientHello up to, but not including, this Finished message. This may be different from handshake_messages in <a href="#server-certificate-verify">Section 7.3.7</a> or <a href="#client-certificate-verify">Section 7.3.10</a>. Also, the handshake_messages for the Finished message sent by the client will be different from that for the Finished message sent by the server, because the one that is sent second will include the prior one.</p>
<p id="rfc.section.7.3.8.p.11">Note: Alerts and any other record types are not handshake messages and are not included in the hash computations. Also, HelloRequest messages are omitted from handshake hashes.</p>
<h1 id="rfc.section.7.3.9"><a href="#rfc.section.7.3.9">7.3.9.</a> <a href="#client-certificate" id="client-certificate">Client Certificate</a></h1>
<p id="rfc.section.7.3.9.p.1">When this message will be sent:</p>
<p/>

<ul class="empty">
  <li>This message is the first handshake message the client can send after receiving the server&#8217;s Finished. This message is only sent if the server requests a certificate. If no suitable certificate is available, the client MUST send a certificate message containing no certificates. That is, the certificate_list structure has a length of zero. If the client does not send any certificates, the server MAY at its discretion either continue the handshake without client authentication, or respond with a fatal handshake_failure alert. Also, if some aspect of the certificate chain was unacceptable (e.g., it was not signed by a known, trusted CA), the server MAY at its discretion either continue the handshake (considering the client unauthenticated) or send a fatal alert.</li>
</ul>
<p/>

<ul class="empty">
  <li>Client certificates are sent using the Certificate structure defined in <a href="#server-certificate">Section 7.3.5</a>.</li>
</ul>
<p id="rfc.section.7.3.9.p.4">Meaning of this message:</p>
<p/>

<ul class="empty">
  <li>This message conveys the client&#8217;s certificate chain to the server; the server will use it when verifying the CertificateVerify message (when the client authentication is based on signing) or calculating the premaster secret (for non-ephemeral Diffie- Hellman). The certificate MUST be appropriate for the negotiated cipher suite&#8217;s key exchange algorithm, and any negotiated extensions.</li>
</ul>
<p id="rfc.section.7.3.9.p.6">In particular:</p>
<pre>
 Client Cert. Type   Certificate Key Type

 rsa_sign            RSA public key; the certificate MUST allow the
                     key to be used for signing with the signature
                     scheme and hash algorithm that will be
                     employed in the certificate verify message.

 dss_sign            DSA public key; the certificate MUST allow the
                     key to be used for signing with the hash
                     algorithm that will be employed in the
                     certificate verify message.

 ecdsa_sign          ECDSA-capable public key; the certificate MUST
                     allow the key to be used for signing with the
                     hash algorithm that will be employed in the
                     certificate verify message; the public key
                     MUST use a curve and point format supported by
                     the server.

 rsa_fixed_dh        Diffie-Hellman public key; MUST use the same
 dss_fixed_dh        parameters as server's key.

 rsa_fixed_ecdh      ECDH-capable public key; MUST use the
 ecdsa_fixed_ecdh    same curve as the server's key, and MUST use a
                     point format supported by the server.
</pre>
<p/>

<ul>
  <li>The certificate type MUST be X.509v3, unless explicitly negotiated otherwise (e.g., <a href="#RFC5081">[RFC5081]</a>).</li>
  <li>The end-entity certificate&#8217;s public key (and associated restrictions) has to be compatible with the certificate types listed in CertificateRequest:  <br/><br/> </li>
  <li>If the certificate_authorities list in the certificate request message was non-empty, one of the certificates in the certificate chain SHOULD be issued by one of the listed CAs.</li>
  <li>The certificates MUST be signed using an acceptable hash/ signature algorithm pair, as described in <a href="#certificate-request">Section 7.3.6</a>.  Note that this relaxes the constraints on certificate-signing algorithms found in prior versions of TLS.</li>
</ul>
<p id="rfc.section.7.3.9.p.8">Note that, as with the server certificate, there are certificates that use algorithms/algorithm combinations that cannot be currently used with TLS.</p>
<h1 id="rfc.section.7.3.10"><a href="#rfc.section.7.3.10">7.3.10.</a> <a href="#client-certificate-verify" id="client-certificate-verify">Client Certificate Verify</a></h1>
<p id="rfc.section.7.3.10.p.1">When this message will be sent:</p>
<p/>

<ul class="empty">
  <li>This message is used to provide explicit verification of a client certificate. This message is only sent following a client certificate that has signing capability (i.e., all certificates except those containing fixed Diffie-Hellman parameters). When sent, it MUST immediately follow the client&#8217;s Certificate message. The contents of the message are computed as described in <a href="#server-certificate-verify">Section 7.3.7</a>, except that the context string is &#8220;TLS 1.3, client CertificateVerify&#8221;.</li>
</ul>
<p/>

<ul class="empty">
  <li>The hash and signature algorithms used in the signature MUST be one of those present in the supported_signature_algorithms field of the CertificateRequest message. In addition, the hash and signature algorithms MUST be compatible with the key in the client&#8217;s end-entity certificate. RSA keys MAY be used with any permitted hash algorithm, subject to restrictions in the certificate, if any.</li>
</ul>
<p/>

<ul class="empty">
  <li>Because DSA signatures do not contain any secure indication of hash algorithm, there is a risk of hash substitution if multiple hashes may be used with any key. Currently, DSA <a href="#DSS">[DSS]</a> may only be used with SHA-1. Future revisions of DSS <a href="#DSS-3">[DSS-3]</a> are expected to allow the use of other digest algorithms with DSA, as well as guidance as to which digest algorithms should be used with each key size. In addition, future revisions of <a href="#RFC3280">[RFC3280]</a> may specify mechanisms for certificates to indicate which digest algorithms are to be used with DSA.</li>
</ul>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#cryptographic-computations" id="cryptographic-computations">Cryptographic Computations</a></h1>
<p id="rfc.section.8.p.1">In order to begin connection protection, the TLS Record Protocol requires specification of a suite of algorithms, a master secret, and the client and server random values. The authentication, key agreement, and record protection algorithms are determined by the cipher_suite selected by the server and revealed in the ServerHello message. The random values are exchanged in the hello messages. All that remains is to calculate the master secret.</p>
<h1 id="rfc.section.8.1"><a href="#rfc.section.8.1">8.1.</a> <a href="#computing-the-master-secret" id="computing-the-master-secret">Computing the Master Secret</a></h1>
<p id="rfc.section.8.1.p.1">The pre_master_secret is used to generate a series of master secret values, as shown in the following diagram and described below.</p>
<pre>
                             Premaster Secret &lt;---------+
                                    |                   |
                                   PRF                  |
                                    |                   |
                                    v                   |
  Handshake   &lt;-PRF-           Handshake                |
 Traffic Keys                 Master Secret             | 
                                    |                   | Via
                                    |                   | Session
                         +----------+----------+        | Cache
                         |                     |        |
                        PRF                   PRF       |
                         |                     |        |
                         v                     v        |
 Application  &lt;-PRF-  Master               Resumption   |
Traffic Keys          Secret               Premaster  --+
                                             Secret
</pre>
<p id="rfc.section.8.1.p.2">First, as soon as the ClientKeyShare and ServerKeyShare messages have been exchanged, the client and server each use the unauthenticated key shares to generate a master secret which is used for the protection of the remaining handshake records. Specifically, they generate:</p>
<pre>
   hs_master_secret = PRF(pre_master_secret, "handshake master secret",
                          session_hash)
                          [0..47];
</pre>
<p id="rfc.section.8.1.p.3">During resumption, the premaster secret is initialized with the &#8220;resumption premaster secret&#8221;, rather than using the values from the ClientKeyShare/ServerKeyShare exchange.</p>
<p id="rfc.section.8.1.p.4">This master secret value is used to generate the record protection keys used for the handshake, as described in <a href="#key-calculation">Section 6.3</a>. It is also used with TLS Exporters <a href="#RFC5705">[RFC5705]</a>.</p>
<p id="rfc.section.8.1.p.5">Once the hs_master_secret has been computed, the premaster secret SHOULD be deleted from memory.</p>
<p id="rfc.section.8.1.p.6">Once the last non-Finished message has been sent, the client and server then compute the master secret which will be used for the remainder of the session:</p>
<pre>
   master_secret = PRF(hs_master_secret, "extended master secret",
                       session_hash)
                       [0..47];
</pre>
<p id="rfc.section.8.1.p.7">If the server does not request client authentication, the master secret can be computed at the time that the server sends its Finished, thus allowing the server to send traffic on its first flight (see [TODO] for security considerations on this practice.)  If the server requests client authentication, this secret can be computed after the client&#8217;s Certificate and CertificateVerify have been sent, or, if the client refuses client authentication, after the client&#8217;s empty Certificate message has been sent.</p>
<p id="rfc.section.8.1.p.8">For full handshakes, each side also derives a new secret which will be used as the premaster_secret for future resumptions of the newly established session. This is computed as:</p>
<pre>
   resumption_premaster_secret = PRF(hs_master_secret,
                                     "resumption premaster secret",
                                     session_hash)
                                     [0..47];
</pre>
<p id="rfc.section.8.1.p.9">The session_hash value is a running hash of the handshake as defined in <a href="#the-session-hash">Section 8.1.1</a>. Thus, the hs_master_secret is generated using a different session_hash from the other two secrets.</p>
<p id="rfc.section.8.1.p.10">All master secrets are always exactly 48 bytes in length. The length of the premaster secret will vary depending on key exchange method.</p>
<h1 id="rfc.section.8.1.1"><a href="#rfc.section.8.1.1">8.1.1.</a> <a href="#the-session-hash" id="the-session-hash">The Session Hash</a></h1>
<p id="rfc.section.8.1.1.p.1">When a handshake takes place, we define</p>
<pre>
     session_hash = Hash(handshake_messages)
</pre>
<p id="rfc.section.8.1.1.p.2">where &#8220;handshake_messages&#8221; refers to all handshake messages sent or received, starting at client hello up to the present time, with the exception of the Finished message, including the type and length fields of the handshake messages. This is the concatenation of all the exchanged Handshake structures.</p>
<p id="rfc.section.8.1.1.p.3">For concreteness, at the point where the handshake master secret is derived, the session hash includes the ClientHello, ClientKeyShare, ServerHello, and ServerKeyShare, and HelloRetryRequest (if any) (though see [https://github.com/tlswg/tls13-spec/issues/104]).  At the point where the master secret is derived, it includes every handshake message, with the exception of the Finished messages.  Note that if client authentication is not used, then the session hash is complete at the point when the server has sent its first flight. Otherwise, it is only complete when the client has sent its first flight, as it covers the client&#8217;s Certificate and CertificateVerify.</p>
<h1 id="rfc.section.8.1.2"><a href="#rfc.section.8.1.2">8.1.2.</a> <a href="#diffie-hellman" id="diffie-hellman">Diffie-Hellman</a></h1>
<p id="rfc.section.8.1.2.p.1">A conventional Diffie-Hellman computation is performed. The negotiated key (Z) is used as the pre_master_secret, and is converted into the master_secret, as specified above. Leading bytes of Z that contain all zero bits are stripped before it is used as the pre_master_secret.</p>
<h1 id="rfc.section.8.1.3"><a href="#rfc.section.8.1.3">8.1.3.</a> <a href="#elliptic-curve-diffie-hellman" id="elliptic-curve-diffie-hellman">Elliptic Curve Diffie-Hellman</a></h1>
<p id="rfc.section.8.1.3.p.1">All ECDH calculations (including parameter and key generation as well as the shared secret calculation) are performed according to [6] using the ECKAS-DH1 scheme with the identity map as key derivation function (KDF), so that the premaster secret is the x-coordinate of the ECDH shared secret elliptic curve point represented as an octet string.  Note that this octet string (Z in IEEE 1363 terminology) as output by FE2OSP, the Field Element to Octet String Conversion Primitive, has constant length for any given field; leading zeros found in this octet string MUST NOT be truncated.</p>
<p id="rfc.section.8.1.3.p.2">(Note that this use of the identity KDF is a technicality.  The complete picture is that ECDH is employed with a non-trivial KDF because TLS does not directly use the premaster secret for anything other than for computing the master secret.)</p>
<h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a> <a href="#mandatory-cipher-suites" id="mandatory-cipher-suites">Mandatory Cipher Suites</a></h1>
<p id="rfc.section.9.p.1">In the absence of an application profile standard specifying otherwise, a TLS-compliant application MUST implement the cipher suite <a href="https://github.com/tlswg/tls13-spec/issues/32">TODO:Needs to be selected</a>. (See <a href="#the-cipher-suite">Appendix A.4</a> for the definition).</p>
<h1 id="rfc.section.10"><a href="#rfc.section.10">10.</a> <a href="#application-data-protocol" id="application-data-protocol">Application Data Protocol</a></h1>
<p id="rfc.section.10.p.1">Application data messages are carried by the record layer and are fragmented and encrypted based on the current connection state. The messages are treated as transparent data to the record layer.</p>
<h1 id="rfc.section.11"><a href="#rfc.section.11">11.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a></h1>
<p id="rfc.section.11.p.1">Security issues are discussed throughout this memo, especially in Appendices D, E, and F.</p>
<h1 id="rfc.section.12"><a href="#rfc.section.12">12.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a></h1>
<p id="rfc.section.12.p.1">[[TODO: Update https://github.com/tlswg/tls13-spec/issues/62]]</p>
<p id="rfc.section.12.p.2">This document uses several registries that were originally created in <a href="#RFC4346">[RFC4346]</a>. IANA has updated these to reference this document. The registries and their allocation policies (unchanged from <a href="#RFC4346">[RFC4346]</a>) are listed below.</p>
<p/>

<ul>
  <li>TLS ClientCertificateType Identifiers Registry: Future values in the range 0-63 (decimal) inclusive are assigned via Standards Action <a href="#RFC2434">[RFC2434]</a>.  Values in the range 64-223 (decimal) inclusive are assigned via Specification Required <a href="#RFC2434">[RFC2434]</a>.  Values from 224-255 (decimal) inclusive are reserved for Private Use <a href="#RFC2434">[RFC2434]</a>.</li>
  <li>TLS Cipher Suite Registry: Future values with the first byte in the range 0-191 (decimal) inclusive are assigned via Standards Action <a href="#RFC2434">[RFC2434]</a>.  Values with the first byte in the range 192-254 (decimal) are assigned via Specification Required <a href="#RFC2434">[RFC2434]</a>.  Values with the first byte 255 (decimal) are reserved for Private Use <a href="#RFC2434">[RFC2434]</a>.</li>
  <li>TLS ContentType Registry: Future values are allocated via Standards Action <a href="#RFC2434">[RFC2434]</a>.</li>
  <li>TLS Alert Registry: Future values are allocated via Standards Action <a href="#RFC2434">[RFC2434]</a>.</li>
  <li>TLS HandshakeType Registry: Future values are allocated via Standards Action <a href="#RFC2434">[RFC2434]</a>.</li>
</ul>
<p id="rfc.section.12.p.4">This document also uses a registry originally created in <a href="#RFC4366">[RFC4366]</a>. IANA has updated it to reference this document. The registry and its allocation policy (unchanged from <a href="#RFC4366">[RFC4366]</a>) is listed below:</p>
<p/>

<ul>
  <li>TLS ExtensionType Registry: Future values are allocated via IETF Consensus <a href="#RFC2434">[RFC2434]</a>.  IANA has updated this registry to include the signature_algorithms extension and its corresponding value (see <a href="#hello-extensions">Section 7.3.2.5</a>).</li>
</ul>
<p id="rfc.section.12.p.6">This document also uses two registries originally created in <a href="#RFC4492">[RFC4492]</a>. IANA [should update/has updated] it to reference this document. The registries and their allocation policies are listed below.</p>
<p/>

<ul>
  <li>TLS NamedCurve registry: Future values are allocated via IETF Consensus <a href="#RFC2434">[RFC2434]</a>.</li>
  <li>TLS ECPointFormat Registry: Future values are allocated via IETF Consensus <a href="#RFC2434">[RFC2434]</a>.</li>
</ul>
<p id="rfc.section.12.p.8">In addition, this document defines two new registries to be maintained by IANA:</p>
<p/>

<ul>
  <li>TLS SignatureAlgorithm Registry: The registry has been initially populated with the values described in <a href="#signature-algorithms">Section 7.3.2.5.1</a>.  Future values in the range 0-63 (decimal) inclusive are assigned via Standards Action <a href="#RFC2434">[RFC2434]</a>.  Values in the range 64-223 (decimal) inclusive are assigned via Specification Required <a href="#RFC2434">[RFC2434]</a>.  Values from 224-255 (decimal) inclusive are reserved for Private Use <a href="#RFC2434">[RFC2434]</a>.</li>
  <li>TLS HashAlgorithm Registry: The registry has been initially populated with the values described in <a href="#signature-algorithms">Section 7.3.2.5.1</a>.  Future values in the range 0-63 (decimal) inclusive are assigned via Standards Action <a href="#RFC2434">[RFC2434]</a>.  Values in the range 64-223 (decimal) inclusive are assigned via Specification Required <a href="#RFC2434">[RFC2434]</a>.  Values from 224-255 (decimal) inclusive are reserved for Private Use <a href="#RFC2434">[RFC2434]</a>.</li>
</ul>
<h1 id="rfc.references"><a href="#rfc.references">13.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">13.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="AES">[AES]</b>
      </td>
      <td class="top"><a>National Institute of Standards and Technology</a>, "<a>Specification for the Advanced Encryption Standard (AES)</a>", NIST FIPS 197, November 2001.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="DSS">[DSS]</b>
      </td>
      <td class="top"><a>National Institute of Standards and Technology, U.S. Department of Commerce</a>, "<a>Digital Signature Standard</a>", NIST FIPS PUB 186-2, 2000.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC1321">[RFC1321]</b>
      </td>
      <td class="top"><a href="mailto:rivest@theory.lcs.mit.edu" title="Massachusetts Institute of Technology, (MIT) Laboratory for Computer Science">Rivest, R.</a>, "<a href="http://tools.ietf.org/html/rfc1321">The MD5 Message-Digest Algorithm</a>", RFC 1321, April 1992.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2104">[RFC2104]</b>
      </td>
      <td class="top"><a href="mailto:hugo@watson.ibm.com" title="IBM, T.J. Watson Research Center">Krawczyk, H.</a>, <a href="mailto:mihir@cs.ucsd.edu" title="University of California at San Diego, Dept of Computer Science and Engineering">Bellare, M.</a> and <a href="mailto:canetti@watson.ibm.com" title="IBM T.J. Watson Research Center">R. Canetti</a>, "<a href="http://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</a>", RFC 2104, February 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2434">[RFC2434]</b>
      </td>
      <td class="top"><a href="mailto:narten@raleigh.ibm.com" title="IBM Corporation">Narten, T.</a> and <a href="mailto:Harald@Alvestrand.no" title="Maxware">H. Alvestrand</a>, "<a href="http://tools.ietf.org/html/rfc2434">Guidelines for Writing an IANA Considerations Section in RFCs</a>", BCP 26, RFC 2434, October 1998.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3280">[RFC3280]</b>
      </td>
      <td class="top"><a>Housley, R.</a>, <a>Polk, W.</a>, <a>Ford, W.</a> and <a>D. Solo</a>, "<a href="http://tools.ietf.org/html/rfc3280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>", RFC 3280, April 2002.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3447">[RFC3447]</b>
      </td>
      <td class="top"><a>Jonsson, J.</a> and <a>B. Kaliski</a>, "<a href="http://tools.ietf.org/html/rfc3447">Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1</a>", RFC 3447, February 2003.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5288">[RFC5288]</b>
      </td>
      <td class="top"><a>Salowey, J.</a>, <a>Choudhury, A.</a> and <a>D. McGrew</a>, "<a href="http://tools.ietf.org/html/rfc5288">AES Galois Counter Mode (GCM) Cipher Suites for TLS</a>", RFC 5288, August 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="SCH">[SCH]</b>
      </td>
      <td class="top"><a>Schneier, B.</a>, "<a>Applied Cryptography: Protocols, Algorithms, and Source Code in C, 2nd ed.</a>", 1996.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="SHS">[SHS]</b>
      </td>
      <td class="top"><a>National Institute of Standards and Technology, U.S. Department of Commerce</a>, "<a>Secure Hash Standard</a>", NIST FIPS PUB 180-2, August 2002.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="TRIPLEDES">[TRIPLEDES]</b>
      </td>
      <td class="top"><a>National Institute of Standards and Technology</a>, "<a>Recommendation for the Triple Data Encryption Algorithm (TDEA) Block Cipher</a>", NIST Special Publication 800-67, May 2004.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="X680">[X680]</b>
      </td>
      <td class="top"><a>ITU-T</a>, "<a>Information technology - Abstract Syntax Notation One (ASN.1): Specification of basic notation</a>", ISO/IEC 8824-1:2002, 2002.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="X690">[X690]</b>
      </td>
      <td class="top"><a>ITU-T</a>, "<a>Information technology - ASN.1 encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)</a>", ISO/IEC 8825-1:2002, 2002.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="X962">[X962]</b>
      </td>
      <td class="top"><a>ANSI</a>, "<a>Public Key Cryptography For The Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA)</a>", ANSI X9.62, 1998.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">13.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="CBCATT">[CBCATT]</b>
      </td>
      <td class="top"><a>Moeller, B.</a>, <a href="http://www.openssl.org/~bodo/tls-cbc.txt">Security of CBC Ciphersuites in SSL/TLS: Problems and Countermeasures</a>", May 2004.</td>
    </tr>
    <tr><td class="reference"><b id="CCM">[CCM]</b></td><td class="top"><a href="http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C.pdf">NIST Special Publication 800-38C: The CCM Mode for Authentication and Confidentiality</a>", May 2004.</td>, "</tr>
    <tr><td class="reference"><b id="DES">[DES]</b></td><td class="top"><a>Data Encryption Standard (DES)</a>", NIST FIPS PUB 46-3, October 1999.</td>, "</tr>
    <tr>
      <td class="reference">
        <b id="DSS-3">[DSS-3]</b>
      </td>
      <td class="top"><a>National Institute of Standards and Technology, U.S.</a>, "<a>Digital Signature Standard</a>", NIST FIPS PUB 186-3 Draft, 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="ECDSA">[ECDSA]</b>
      </td>
      <td class="top"><a>American National Standards Institute</a>, "<a>Public Key Cryptography for the Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA)</a>", ANSI ANS X9.62-2005, November 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="ENCAUTH">[ENCAUTH]</b>
      </td>
      <td class="top"><a>Krawczyk, H.</a>, <a>The Order of Encryption and Authentication for Protecting Communications (Or: How Secure is SSL?)</a>", 2001.</td>
    </tr>
    <tr><td class="reference"><b id="FI06">[FI06]</b></td><td class="top"><a href="http://www.imc.org/ietf-openpgp/mail-archive/msg14307.html">Bleichenbacher's RSA signature forgery based on implementation error</a>", August 2006.</td>, "</tr>
    <tr>
      <td class="reference">
        <b id="GCM">[GCM]</b>
      </td>
      <td class="top"><a>Dworkin, M.</a>, "<a>Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC</a>", NIST Special Publication 800-38D, November 2007.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-tls-negotiated-ff-dhe">[I-D.ietf-tls-negotiated-ff-dhe]</b>
      </td>
      <td class="top"><a>Gillmor, D.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-tls-negotiated-ff-dhe-05">Negotiated Finite Field Diffie-Hellman Ephemeral Parameters for TLS</a>", Internet-Draft draft-ietf-tls-negotiated-ff-dhe-05, December 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-tls-session-hash">[I-D.ietf-tls-session-hash]</b>
      </td>
      <td class="top"><a>Bhargavan, K.</a>, <a>Delignat-Lavaud, A.</a>, <a>Pironti, A.</a>, <a>Langley, A.</a> and <a>M. Ray</a>, "<a href="http://tools.ietf.org/html/draft-ietf-tls-session-hash-03">Transport Layer Security (TLS) Session Hash and Extended Master Secret Extension</a>", Internet-Draft draft-ietf-tls-session-hash-03, November 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-tls-sslv3-diediedie">[I-D.ietf-tls-sslv3-diediedie]</b>
      </td>
      <td class="top"><a>Barnes, R.</a>, <a>Thomson, M.</a>, <a>Pironti, A.</a> and <a>A. Langley</a>, "<a href="http://tools.ietf.org/html/draft-ietf-tls-sslv3-diediedie-00">Deprecating Secure Sockets Layer Version 3.0</a>", Internet-Draft draft-ietf-tls-sslv3-diediedie-00, December 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="PKCS6">[PKCS6]</b>
      </td>
      <td class="top"><a>RSA Laboratories</a>, "<a>PKCS #6: RSA Extended Certificate Syntax Standard, version 1.5</a>", November 1993.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="PKCS7">[PKCS7]</b>
      </td>
      <td class="top"><a>RSA Laboratories</a>, "<a>PKCS #7: RSA Cryptographic Message Syntax Standard, version 1.5</a>", November 1993.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC0793">[RFC0793]</b>
      </td>
      <td class="top"><a title="University of Southern California (USC)/Information Sciences Institute">Postel, J.</a>, "<a href="http://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>", STD 7, RFC 793, September 1981.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC1948">[RFC1948]</b>
      </td>
      <td class="top"><a href="mailto:smb@research.att.com" title="AT&amp;T Research">Bellovin, S.</a>, "<a href="http://tools.ietf.org/html/rfc1948">Defending Against Sequence Number Attacks</a>", RFC 1948, May 1996.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2246">[RFC2246]</b>
      </td>
      <td class="top"><a href="mailto:tdierks@certicom.com" title="Certicom">Dierks, T.</a> and <a href="mailto:callen@certicom.com" title="Certicom">C. Allen</a>, "<a href="http://tools.ietf.org/html/rfc2246">The TLS Protocol Version 1.0</a>", RFC 2246, January 1999.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2785">[RFC2785]</b>
      </td>
      <td class="top"><a href="mailto:robert.zuccherato@entrust.com" title="Entrust Technologies">Zuccherato, R.</a>, "<a href="http://tools.ietf.org/html/rfc2785">Methods for Avoiding the "Small-Subgroup" Attacks on the Diffie-Hellman Key Agreement Method for S/MIME</a>", RFC 2785, March 2000.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3268">[RFC3268]</b>
      </td>
      <td class="top"><a>Chown, P.</a>, "<a href="http://tools.ietf.org/html/rfc3268">Advanced Encryption Standard (AES) Ciphersuites for Transport Layer Security (TLS)</a>", RFC 3268, June 2002.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3526">[RFC3526]</b>
      </td>
      <td class="top"><a>Kivinen, T.</a> and <a>M. Kojo</a>, "<a href="http://tools.ietf.org/html/rfc3526">More Modular Exponential (MODP) Diffie-Hellman groups for Internet Key Exchange (IKE)</a>", RFC 3526, May 2003.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3766">[RFC3766]</b>
      </td>
      <td class="top"><a>Orman, H.</a> and <a>P. Hoffman</a>, "<a href="http://tools.ietf.org/html/rfc3766">Determining Strengths For Public Keys Used For Exchanging Symmetric Keys</a>", BCP 86, RFC 3766, April 2004.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4086">[RFC4086]</b>
      </td>
      <td class="top"><a>Eastlake, D.</a>, <a>Schiller, J.</a> and <a>S. Crocker</a>, "<a href="http://tools.ietf.org/html/rfc4086">Randomness Requirements for Security</a>", BCP 106, RFC 4086, June 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4302">[RFC4302]</b>
      </td>
      <td class="top"><a>Kent, S.</a>, "<a href="http://tools.ietf.org/html/rfc4302">IP Authentication Header</a>", RFC 4302, December 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4303">[RFC4303]</b>
      </td>
      <td class="top"><a>Kent, S.</a>, "<a href="http://tools.ietf.org/html/rfc4303">IP Encapsulating Security Payload (ESP)</a>", RFC 4303, December 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4307">[RFC4307]</b>
      </td>
      <td class="top"><a>Schiller, J.</a>, "<a href="http://tools.ietf.org/html/rfc4307">Cryptographic Algorithms for Use in the Internet Key Exchange Version 2 (IKEv2)</a>", RFC 4307, December 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4346">[RFC4346]</b>
      </td>
      <td class="top"><a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc4346">The Transport Layer Security (TLS) Protocol Version 1.1</a>", RFC 4346, April 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4366">[RFC4366]</b>
      </td>
      <td class="top"><a>Blake-Wilson, S.</a>, <a>Nystrom, M.</a>, <a>Hopwood, D.</a>, <a>Mikkelsen, J.</a> and <a>T. Wright</a>, "<a href="http://tools.ietf.org/html/rfc4366">Transport Layer Security (TLS) Extensions</a>", RFC 4366, April 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4492">[RFC4492]</b>
      </td>
      <td class="top"><a>Blake-Wilson, S.</a>, <a>Bolyard, N.</a>, <a>Gupta, V.</a>, <a>Hawk, C.</a> and <a>B. Moeller</a>, "<a href="http://tools.ietf.org/html/rfc4492">Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)</a>", RFC 4492, May 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4506">[RFC4506]</b>
      </td>
      <td class="top"><a>Eisler, M.</a>, "<a href="http://tools.ietf.org/html/rfc4506">XDR: External Data Representation Standard</a>", STD 67, RFC 4506, May 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5081">[RFC5081]</b>
      </td>
      <td class="top"><a>Mavrogiannopoulos, N.</a>, "<a href="http://tools.ietf.org/html/rfc5081">Using OpenPGP Keys for Transport Layer Security (TLS) Authentication</a>", RFC 5081, November 2007.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5116">[RFC5116]</b>
      </td>
      <td class="top"><a>McGrew, D.</a>, "<a href="http://tools.ietf.org/html/rfc5116">An Interface and Algorithms for Authenticated Encryption</a>", RFC 5116, January 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5705">[RFC5705]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/rfc5705">Keying Material Exporters for Transport Layer Security (TLS)</a>", RFC 5705, March 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6176">[RFC6176]</b>
      </td>
      <td class="top"><a>Turner, S.</a> and <a>T. Polk</a>, "<a href="http://tools.ietf.org/html/rfc6176">Prohibiting Secure Sockets Layer (SSL) Version 2.0</a>", RFC 6176, March 2011.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RSA">[RSA]</b>
      </td>
      <td class="top"><a>Rivest, R.</a>, <a>Shamir, A.</a> and <a>L. Adleman</a>, "<a>A Method for Obtaining Digital Signatures and Public-Key Cryptosystems</a>", Communications of the ACM v. 21, n. 2, pp. 120-126., February 1978.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="SSL2">[SSL2]</b>
      </td>
      <td class="top"><a>Netscape Communications Corp.</a>, "<a>The SSL Protocol</a>", February 1995.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="SSL3">[SSL3]</b>
      </td>
      <td class="top"><a title="Netscape Communications Corp.">Freier, A.</a>, <a title="Netscape Communications Corp.">Karlton, P.</a> and <a title="Netscape Communications Corp.">P. Kocher</a>, "<a>The SSL 3.0 Protocol</a>", November 1996.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="TIMING">[TIMING]</b>
      </td>
      <td class="top"><a>Boneh, D.</a> and <a>D. Brumley</a>, "<a>Remote timing attacks are practical</a>", USENIX Security Symposium, 2003.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="TLSEXT">[TLSEXT]</b>
      </td>
      <td class="top"><a>Eastlake 3rd, D.</a>, <a>Transport Layer Security (TLS) Extensions:  Extension Definitions</a>", February 2008.</td>
    </tr>
    <tr><td class="reference"><b id="X501">[X501]</b></td><td class="top"><a>Information Technology - Open Systems Interconnection - The Directory: Models</a>", ITU-T X.501, 1993.</td>, "</tr>
  </tbody>
</table>
<h1 id="rfc.appendix.A"><a href="#rfc.appendix.A">Appendix A.</a> <a href="#protocol-data-structures-and-constant-values" id="protocol-data-structures-and-constant-values">Protocol Data Structures and Constant Values</a></h1>
<p id="rfc.section.A.p.1">This section describes protocol types and constants.</p>
<h1 id="rfc.appendix.A.1"><a href="#rfc.appendix.A.1">A.1.</a> <a href="#record-layer-1" id="record-layer-1">Record Layer</a></h1>
<pre>
   struct {
       uint8 major;
       uint8 minor;
   } ProtocolVersion;

   ProtocolVersion version = { 3, 4 };     /* TLS v1.3*/

   enum {
       reserved(20), alert(21), handshake(22),
       application_data(23), (255)
   } ContentType;

   struct {
       ContentType type;
       ProtocolVersion version;
       uint16 length;
       opaque fragment[TLSPlaintext.length];
   } TLSPlaintext;

   struct {
       ContentType type;
       ProtocolVersion version;
       uint16 length;
       opaque nonce_explicit[SecurityParameters.record_iv_length];
       aead-ciphered struct {
          opaque content[TLSPlaintext.length];
       } fragment;
   } TLSCiphertext;
</pre>
<h1 id="rfc.appendix.A.2"><a href="#rfc.appendix.A.2">A.2.</a> <a href="#alert-messages" id="alert-messages">Alert Messages</a></h1>
<pre>
   enum { warning(1), fatal(2), (255) } AlertLevel;

   enum {
       close_notify(0),
       unexpected_message(10),
       bad_record_mac(20),
       decryption_failed_RESERVED(21),
       record_overflow(22),
       decompression_failure_RESERVED(30),
       handshake_failure(40),
       no_certificate_RESERVED(41),
       bad_certificate(42),
       unsupported_certificate(43),
       certificate_revoked(44),
       certificate_expired(45),
       certificate_unknown(46),
       illegal_parameter(47),
       unknown_ca(48),
       access_denied(49),
       decode_error(50),
       decrypt_error(51),
       export_restriction_RESERVED(60),
       protocol_version(70),
       insufficient_security(71),
       internal_error(80),
       user_canceled(90),
       no_renegotiation(100),
       unsupported_extension(110),
       (255)
   } AlertDescription;

   struct {
       AlertLevel level;
       AlertDescription description;
   } Alert;
</pre>
<h1 id="rfc.appendix.A.3"><a href="#rfc.appendix.A.3">A.3.</a> <a href="#handshake-protocol-1" id="handshake-protocol-1">Handshake Protocol</a></h1>
<pre>
   enum {
       reserved(0), client_hello(1), server_hello(2),
       client_key_share(5), hello_retry_request(6),
       server_key_share(7), certificate(11), reserved(12),
       certificate_request(13), certificate_verify(15),
       reserved(16), finished(20), (255)
   } HandshakeType;

   struct {
       HandshakeType msg_type;    /* handshake type */
       uint24 length;             /* bytes in message */
       select (HandshakeType) {
           case client_hello:        ClientHello;
           case client_key_share:    ClientKeyShare;
           case server_hello:        ServerHello;
           case hello_retry_request: HelloRetryRequest;
           case server_key_share:    ServerKeyShare;
           case certificate:         Certificate;
           case certificate_request: CertificateRequest;
           case certificate_verify:  CertificateVerify;
           case finished:            Finished;
       } body;
   } Handshake;
</pre>
<h1 id="rfc.appendix.A.3.1"><a href="#rfc.appendix.A.3.1">A.3.1.</a> <a href="#hello-messages-1" id="hello-messages-1">Hello Messages</a></h1>
<pre>
   opaque SessionID&lt;0..32&gt;;

   uint8 CipherSuite[2];    /* Cryptographic suite selector */

   enum { null(0), (255) } CompressionMethod;

   struct {
       ProtocolVersion client_version;
       Random random;
       SessionID session_id;
       CipherSuite cipher_suites&lt;2..2^16-2&gt;;
       CompressionMethod compression_methods&lt;1..2^8-1&gt;;
       select (extensions_present) {
           case false:
               struct {};
           case true:
               Extension extensions&lt;0..2^16-1&gt;;
       };
   } ClientHello;

   struct {
       ProtocolVersion server_version;
       Random random;
       SessionID session_id;
       CipherSuite cipher_suite;
       select (extensions_present) {
           case false:
               struct {};
           case true:
               Extension extensions&lt;0..2^16-1&gt;;
       };
   } ServerHello;

   struct {
       ProtocolVersion server_version;
       CipherSuite cipher_suite;
       NamedGroup selected_group;
       Extension extensions&lt;0..2^16-1&gt;;
   } HelloRetryRequest;

   struct {
       ExtensionType extension_type;
       opaque extension_data&lt;0..2^16-1&gt;;
   } Extension;

   enum {
       signature_algorithms(13), early_data(TBD), (65535)
   } ExtensionType;

      struct {
        TLSCipherText messages&lt;5 .. 2^24-1&gt;;
      } EarlyDataExtension;

   struct {
       Extension extensions&lt;0..2^16-1&gt;;
   } EncryptedExtensions;
</pre>
<h1 id="rfc.appendix.A.3.1.1"><a href="#rfc.appendix.A.3.1.1">A.3.1.1.</a> <a href="#signature-algorithm-extension" id="signature-algorithm-extension">Signature Algorithm Extension</a></h1>
<pre>
   enum {
       none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5),
       sha512(6), (255)
   } HashAlgorithm;

   enum { anonymous(0), rsa(1), dsa(2), ecdsa(3), (255) }
     SignatureAlgorithm;

   struct {
         HashAlgorithm hash;
         SignatureAlgorithm signature;
   } SignatureAndHashAlgorithm;

   SignatureAndHashAlgorithm
     supported_signature_algorithms&lt;2..2^16-2&gt;;
</pre>
<h1 id="rfc.appendix.A.3.1.2"><a href="#rfc.appendix.A.3.1.2">A.3.1.2.</a> <a href="#named-group-extension" id="named-group-extension">Named Group Extension</a></h1>
<pre>
    enum {
        // Elliptic Curve Groups.
        sect163k1 (1), sect163r1 (2), sect163r2 (3),
        sect193r1 (4), sect193r2 (5), sect233k1 (6),
        sect233r1 (7), sect239k1 (8), sect283k1 (9),
        sect283r1 (10), sect409k1 (11), sect409r1 (12),
        sect571k1 (13), sect571r1 (14), secp160k1 (15),
        secp160r1 (16), secp160r2 (17), secp192k1 (18),
        secp192r1 (19), secp224k1 (20), secp224r1 (21),
        secp256k1 (22), secp256r1 (23), secp384r1 (24),
        secp521r1 (25),

        // Finite Field Groups.
        ffdhe2048(256), ffdhe3072(257), ffdhe4096(258),
        ffdhe8192(259),

        // Reserved Code Points.
        reserved (0xFE00..0xFEFF),
        reserved(0xFF01),
        reserved(0xFF02),
        (0xFFFF)
    } NamedGroup;

    struct {
        NamedGroup named_group_list&lt;1..2^16-1&gt;
    } NamedGroupList;
</pre>
<h1 id="rfc.appendix.A.3.2"><a href="#rfc.appendix.A.3.2">A.3.2.</a> <a href="#key-exchange-messages" id="key-exchange-messages">Key Exchange Messages</a></h1>
<pre>
   struct {
       NamedGroup group;
       opaque key_exchange&lt;1..2^16-1&gt;;
   } ClientKeyShareOffer;

   struct {
       ClientKeyShareOffer offers&lt;0..2^16-1&gt;;
   } ClientKeyShare;

   opaque dh_Y&lt;1..2^16-1&gt;;

   opaque point &lt;1..2^8-1&gt;;

   struct {
     NamedGroup group;
     opaque key_exchange&lt;1..2^16-1&gt;;
   } ServerKeyShare;
</pre>
<h1 id="rfc.appendix.A.3.3"><a href="#rfc.appendix.A.3.3">A.3.3.</a> <a href="#authentication-messages" id="authentication-messages">Authentication Messages</a></h1>
<pre>
   opaque ASN1Cert&lt;1..2^24-1&gt;;

   struct {
       ASN1Cert certificate_list&lt;0..2^24-1&gt;;
   } Certificate;

   enum {
       rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
       rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),
       fortezza_dms_RESERVED(20), (255)
   } ClientCertificateType;

   opaque DistinguishedName&lt;1..2^16-1&gt;;

   struct {
       ClientCertificateType certificate_types&lt;1..2^8-1&gt;;
       SignatureAndHashAlgorithm
         supported_signature_algorithms&lt;2..2^16-2&gt;;
       DistinguishedName certificate_authorities&lt;0..2^16-1&gt;;
   } CertificateRequest;

   struct {
        digitally-signed struct {
            opaque handshake_messages_hash[hash_length];
        }
   } CertificateVerify;
</pre>
<h1 id="rfc.appendix.A.3.4"><a href="#rfc.appendix.A.3.4">A.3.4.</a> <a href="#handshake-finalization-messages" id="handshake-finalization-messages">Handshake Finalization Messages</a></h1>
<pre>
   struct {
       opaque verify_data[verify_data_length];
   } Finished;
</pre>
<h1 id="rfc.appendix.A.4"><a href="#rfc.appendix.A.4">A.4.</a> <a href="#the-cipher-suite" id="the-cipher-suite">The Cipher Suite</a></h1>
<p id="rfc.section.A.4.p.1">The following values define the cipher suite codes used in the ClientHello and ServerHello messages.</p>
<p id="rfc.section.A.4.p.2">A cipher suite defines a cipher specification supported in TLS Version 1.2.</p>
<p id="rfc.section.A.4.p.3">TLS_NULL_WITH_NULL_NULL is specified and is the initial state of a TLS connection during the first handshake on that channel, but MUST NOT be negotiated, as it provides no more protection than an unsecured connection.</p>
<pre>
   CipherSuite TLS_NULL_WITH_NULL_NULL             = { 0x00,0x00 };
</pre>
<p id="rfc.section.A.4.p.4">The following cipher suite definitions, defined in {{RFC5288}, are used for server-authenticated (and optionally client-authenticated) Diffie-Hellman. DHE denotes ephemeral Diffie-Hellman, where the Diffie-Hellman parameters are signed by a signature-capable certificate, which has been signed by the CA. The signing algorithm used by the server is specified after the DHE component of the CipherSuite name. The server can request any signature-capable certificate from the client for client authentication.</p>
<pre>
  CipherSuite TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = {0x00,0x9E}
  CipherSuite TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = {0x00,0x9F}
  CipherSuite TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 = {0x00,0xA2}
  CipherSuite TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 = {0x00,0xA3}
</pre>
<p id="rfc.section.A.4.p.5">The following cipher suite definitions, defined in {{RFC5289}, are used for server-authenticated (and optionally client-authenticated) Elliptic Curve Diffie-Hellman. ECDHE denotes ephemeral Diffie-Hellman, where the Diffie-Hellman parameters are signed by a signature-capable certificate, which has been signed by the CA. The signing algorithm used by the server is specified after the DHE component of the CipherSuite name. The server can request any signature-capable certificate from the client for client authentication.</p>
<pre>
 CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256  = {0xC0,0x2B};
 CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384  = {0xC0,0x2C};
 CipherSuite TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256    = {0xC0,0x2F};
 CipherSuite TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384    = {0xC0,0x30};
</pre>
<p id="rfc.section.A.4.p.6">The following ciphers, defined in <a href="#RFC5288">[RFC5288]</a>, are used for completely anonymous Diffie-Hellman communications in which neither party is authenticated. Note that this mode is vulnerable to man-in-the-middle attacks. Using this mode therefore is of limited use: These cipher suites MUST NOT be used by TLS 1.2 implementations unless the application layer has specifically requested to allow anonymous key exchange. (Anonymous key exchange may sometimes be acceptable, for example, to support opportunistic encryption when no set-up for authentication is in place, or when TLS is used as part of more complex security protocols that have other means to ensure authentication.)</p>
<pre>
  CipherSuite TLS_DH_anon_WITH_AES_128_GCM_SHA256 = {0x00,0xA6}
  CipherSuite TLS_DH_anon_WITH_AES_256_GCM_SHA384 = {0x00,0xA7}
</pre>
<p id="rfc.section.A.4.p.7">[[TODO: Add all the defined AEAD ciphers. This currently only lists GCM. https://github.com/tlswg/tls13-spec/issues/53]] Note that using non-anonymous key exchange without actually verifying the key exchange is essentially equivalent to anonymous key exchange, and the same precautions apply. While non-anonymous key exchange will generally involve a higher computational and communicational cost than anonymous key exchange, it may be in the interest of interoperability not to disable non-anonymous key exchange when the application layer is allowing anonymous key exchange.</p>
<p id="rfc.section.A.4.p.8">The PRFs SHALL be as follows:</p>
<p id="rfc.section.A.4.p.9">o  For cipher suites ending with _SHA256, the PRF is the TLS PRF with SHA-256 as the hash function.</p>
<p id="rfc.section.A.4.p.10">o  For cipher suites ending with _SHA384, the PRF is the TLS PRF with SHA-384 as the hash function.</p>
<p id="rfc.section.A.4.p.11">New cipher suite values are been assigned by IANA as described in <a href="#iana-considerations">Section 12</a>.</p>
<p id="rfc.section.A.4.p.12">Note: The cipher suite values { 0x00, 0x1C } and { 0x00, 0x1D } are reserved to avoid collision with Fortezza-based cipher suites in SSL 3.</p>
<h1 id="rfc.appendix.A.5"><a href="#rfc.appendix.A.5">A.5.</a> <a href="#the-security-parameters" id="the-security-parameters">The Security Parameters</a></h1>
<p id="rfc.section.A.5.p.1">These security parameters are determined by the TLS Handshake Protocol and provided as parameters to the TLS record layer in order to initialize a connection state. SecurityParameters includes:</p>
<pre>
   enum { server, client } ConnectionEnd;

   enum { tls_prf_sha256 } PRFAlgorithm;

   enum { aes_gcm } RecordProtAlgorithm;

   /* The algorithms specified in PRFAlgorithm and
      RecordProtAlgorithm may be added to. */

   struct {
       ConnectionEnd          entity;
       PRFAlgorithm           prf_algorithm;
       RecordProtAlgorithm    record_prot_algorithm;
       uint8                  enc_key_length;
       uint8                  block_length;
       uint8                  fixed_iv_length;
       uint8                  record_iv_length;
       opaque                 hs_master_secret[48];
       opaque                 master_secret[48];
       opaque                 client_random[32];
       opaque                 server_random[32];
   } SecurityParameters;
</pre>
<h1 id="rfc.appendix.A.6"><a href="#rfc.appendix.A.6">A.6.</a> <a href="#changes-to-rfc-4492" id="changes-to-rfc-4492">Changes to RFC 4492</a></h1>
<p id="rfc.section.A.6.p.1">RFC 4492 <a href="#RFC4492">[RFC4492]</a> adds Elliptic Curve cipher suites to TLS. This document changes some of the structures used in that document. This section details the required changes for implementors of both RFC 4492 and TLS 1.2. Implementors of TLS 1.2 who are not implementing RFC 4492 do not need to read this section.</p>
<p id="rfc.section.A.6.p.2">This document adds a &#8220;signature_algorithm&#8221; field to the digitally- signed element in order to identify the signature and digest algorithms used to create a signature. This change applies to digital signatures formed using ECDSA as well, thus allowing ECDSA signatures to be used with digest algorithms other than SHA-1, provided such use is compatible with the certificate and any restrictions imposed by future revisions of <a href="#RFC3280">[RFC3280]</a>.</p>
<p id="rfc.section.A.6.p.3">As described in <a href="#server-certificate">Section 7.3.5</a> and <a href="#client-certificate">Section 7.3.9</a>, the restrictions on the signature algorithms used to sign certificates are no longer tied to the cipher suite (when used by the server) or the ClientCertificateType (when used by the client). Thus, the restrictions on the algorithm used to sign certificates specified in Sections 2 and 3 of RFC 4492 are also relaxed. As in this document, the restrictions on the keys in the end-entity certificate remain.</p>
<h1 id="rfc.appendix.B"><a href="#rfc.appendix.B">Appendix B.</a> <a href="#glossary" id="glossary">Glossary</a></h1>
<p/>

<dl>
  <dt>Advanced Encryption Standard (AES)</dt>
  <dd style="margin-left: 8"><br/> AES <a href="#AES">[AES]</a> is a widely used symmetric encryption algorithm.  AES is a block cipher with a 128-, 192-, or 256-bit keys and a 16-byte block size.  TLS currently only supports the 128- and 256-bit key sizes.</dd>
  <dt>application protocol</dt>
  <dd style="margin-left: 8"><br/> An application protocol is a protocol that normally layers directly on top of the transport layer (e.g., TCP/IP).  Examples include HTTP, TELNET, FTP, and SMTP.</dd>
  <dt>asymmetric cipher</dt>
  <dd style="margin-left: 8"><br/> See public key cryptography.</dd>
  <dt>authenticated encryption with additional data (AEAD)</dt>
  <dd style="margin-left: 8"><br/> A symmetric encryption algorithm that simultaneously provides confidentiality and message integrity.</dd>
  <dt>authentication</dt>
  <dd style="margin-left: 8"><br/> Authentication is the ability of one entity to determine the identity of another entity.</dd>
  <dt>certificate</dt>
  <dd style="margin-left: 8"><br/> As part of the X.509 protocol (a.k.a. ISO Authentication framework), certificates are assigned by a trusted Certificate Authority and provide a strong binding between a party&#8217;s identity or some other attributes and its public key.</dd>
  <dt>client</dt>
  <dd style="margin-left: 8"><br/> The application entity that initiates a TLS connection to a server.  This may or may not imply that the client initiated the underlying transport connection.  The primary operational difference between the server and client is that the server is generally authenticated, while the client is only optionally authenticated.</dd>
  <dt>client write key</dt>
  <dd style="margin-left: 8"><br/> The key used to protect data written by the client.</dd>
  <dt>connection</dt>
  <dd style="margin-left: 8"><br/> A connection is a transport (in the OSI layering model definition) that provides a suitable type of service.  For TLS, such connections are peer-to-peer relationships.  The connections are transient.  Every connection is associated with one session.</dd>
  <dt>Digital Signature Standard (DSS)</dt>
  <dd style="margin-left: 8"><br/> A standard for digital signing, including the Digital Signing Algorithm, approved by the National Institute of Standards and Technology, defined in NIST FIPS PUB 186-2, &#8220;Digital Signature Standard&#8221;, published January 2000 by the U.S. Department of Commerce <a href="#DSS">[DSS]</a>.  A significant update <a href="#DSS-3">[DSS-3]</a> has been drafted and was published in March 2006.</dd>
  <dt>digital signatures</dt>
  <dd style="margin-left: 8"><br/> Digital signatures utilize public key cryptography and one-way hash functions to produce a signature of the data that can be authenticated, and is difficult to forge or repudiate.</dd>
  <dt>handshake</dt>
  <dd style="margin-left: 8"><br/> An initial negotiation between client and server that establishes the parameters of their transactions.</dd>
  <dt>Initialization Vector (IV)</dt>
  <dd style="margin-left: 8"><br/> Some AEAD ciphers require an initialization vector to allow the cipher to safely protect multiple chunks of data with the same keying material. The size of the IV depends on the cipher suite.</dd>
  <dt>Message Authentication Code (MAC)</dt>
  <dd style="margin-left: 8"><br/> A Message Authentication Code is a one-way hash computed from a message and some secret data.  It is difficult to forge without knowing the secret data.  Its purpose is to detect if the message has been altered.</dd>
  <dt>master secret</dt>
  <dd style="margin-left: 8"><br/> Secure secret data used for generating keys and IVs.</dd>
  <dt>MD5</dt>
  <dd style="margin-left: 8"><br/> MD5 <a href="#RFC1321">[RFC1321]</a> is a hashing function that converts an arbitrarily long data stream into a hash of fixed size (16 bytes).  Due to significant progress in cryptanalysis, at the time of publication of this document, MD5 no longer can be considered a &#8216;secure&#8217; hashing function.</dd>
  <dt>public key cryptography</dt>
  <dd style="margin-left: 8"><br/> A class of cryptographic techniques employing two-key ciphers.  Messages encrypted with the public key can only be decrypted with the associated private key.  Conversely, messages signed with the private key can be verified with the public key.</dd>
  <dt>one-way hash function</dt>
  <dd style="margin-left: 8"><br/> A one-way transformation that converts an arbitrary amount of data into a fixed-length hash.  It is computationally hard to reverse the transformation or to find collisions.  MD5 and SHA are examples of one-way hash functions.</dd>
  <dt>RSA</dt>
  <dd style="margin-left: 8"><br/> A very widely used public key algorithm that can be used for either encryption or digital signing.  <a href="#RSA">[RSA]</a></dd>
  <dt>server</dt>
  <dd style="margin-left: 8"><br/> The server is the application entity that responds to requests for connections from clients.  See also &#8220;client&#8221;.</dd>
  <dt>session</dt>
  <dd style="margin-left: 8"><br/> A TLS session is an association between a client and a server.  Sessions are created by the handshake protocol.  Sessions define a set of cryptographic security parameters that can be shared among multiple connections.  Sessions are used to avoid the expensive negotiation of new security parameters for each connection.</dd>
  <dt>session identifier</dt>
  <dd style="margin-left: 8"><br/> A session identifier is a value generated by a server that identifies a particular session.</dd>
  <dt>server write key</dt>
  <dd style="margin-left: 8"><br/> The key used to protect data written by the server.</dd>
  <dt>SHA</dt>
  <dd style="margin-left: 8"><br/> The Secure Hash Algorithm <a href="#SHS">[SHS]</a> is defined in FIPS PUB 180-2.  It produces a 20-byte output.  Note that all references to SHA (without a numerical suffix) actually use the modified SHA-1 algorithm.</dd>
  <dt>SHA-256</dt>
  <dd style="margin-left: 8"><br/> The 256-bit Secure Hash Algorithm is defined in FIPS PUB 180-2.  It produces a 32-byte output.</dd>
  <dt>SSL</dt>
  <dd style="margin-left: 8"><br/> Netscape&#8217;s Secure Socket Layer protocol <a href="#SSL3">[SSL3]</a>.  TLS is based on SSL Version 3.0.</dd>
  <dt>Transport Layer Security (TLS)</dt>
  <dd style="margin-left: 8"><br/> This protocol; also, the Transport Layer Security working group of the Internet Engineering Task Force (IETF).  See &#8220;Working Group Information&#8221; at the end of this document (see page 99).</dd>
</dl>
<h1 id="rfc.appendix.C"><a href="#rfc.appendix.C">Appendix C.</a> <a href="#cipher-suite-definitions" id="cipher-suite-definitions">Cipher Suite Definitions</a></h1>
<pre>
Cipher Suite                          Key        Record
                                      Exchange   Protection   PRF

TLS_NULL_WITH_NULL_NULL               NULL       NULL_NULL    N/A
TLS_DHE_RSA_WITH_AES_128_GCM_SHA256   DHE_RSA    AES_128_GCM  SHA256
TLS_DHE_RSA_WITH_AES_256_GCM_SHA384   DHE_RSA    AES_256_GCM  SHA384
TLS_DHE_DSS_WITH_AES_128_GCM_SHA256   DHE_DSS    AES_128_GCM  SHA256
TLS_DHE_DSS_WITH_AES_256_GCM_SHA384   DHE_DSS    AES_256_GCM  SHA384
TLS_DH_anon_WITH_AES_128_GCM_SHA256   DH_anon    AES_128_GCM  SHA256
TLS_DH_anon_WITH_AES_256_GCM_SHA384   DH_anon    AES_128_GCM  SHA384

                Key      Implicit IV   Explicit IV
Cipher         Material  Size          Size
------------   --------  ----------    -----------
NULL               0          0             0
AES_128_GCM       16          4             8
AES_256_GCM       32          4             8
</pre>
<p/>

<dl>
  <dt>Key Material</dt>
  <dd style="margin-left: 8"><br/> The number of bytes from the key_block that are used for generating the write keys.</dd>
  <dt>Implicit IV Size</dt>
  <dd style="margin-left: 8"><br/> The amount of data to be generated for the per-connection part of the initialization vector. This is equal to SecurityParameters.fixed_iv_length).</dd>
  <dt>Explicit IV Size</dt>
  <dd style="margin-left: 8"><br/> The amount of data needed to be generated for the per-record part of the initialization vector. This is equal to SecurityParameters.record_iv_length).</dd>
</dl>
<h1 id="rfc.appendix.D"><a href="#rfc.appendix.D">Appendix D.</a> <a href="#implementation-notes" id="implementation-notes">Implementation Notes</a></h1>
<p id="rfc.section.D.p.1">The TLS protocol cannot prevent many common security mistakes. This section provides several recommendations to assist implementors.</p>
<h1 id="rfc.appendix.D.1"><a href="#rfc.appendix.D.1">D.1.</a> <a href="#random-number-generation-and-seeding" id="random-number-generation-and-seeding">Random Number Generation and Seeding</a></h1>
<p id="rfc.section.D.1.p.1">TLS requires a cryptographically secure pseudorandom number generator (PRNG).  Care must be taken in designing and seeding PRNGs. PRNGs based on secure hash operations, most notably SHA-1, are acceptable, but cannot provide more security than the size of the random number generator state.</p>
<p id="rfc.section.D.1.p.2">To estimate the amount of seed material being produced, add the number of bits of unpredictable information in each seed byte. For example, keystroke timing values taken from a PC compatible&#8217;s 18.2 Hz timer provide 1 or 2 secure bits each, even though the total size of the counter value is 16 bits or more.  Seeding a 128-bit PRNG would thus require approximately 100 such timer values.</p>
<p><a href="#RFC4086">[RFC4086]</a> provides guidance on the generation of random values.</p>
<h1 id="rfc.appendix.D.2"><a href="#rfc.appendix.D.2">D.2.</a> <a href="#certificates-and-authentication" id="certificates-and-authentication">Certificates and Authentication</a></h1>
<p id="rfc.section.D.2.p.1">Implementations are responsible for verifying the integrity of certificates and should generally support certificate revocation messages. Certificates should always be verified to ensure proper signing by a trusted Certificate Authority (CA). The selection and addition of trusted CAs should be done very carefully.  Users should be able to view information about the certificate and root CA.</p>
<h1 id="rfc.appendix.D.3"><a href="#rfc.appendix.D.3">D.3.</a> <a href="#cipher-suites" id="cipher-suites">Cipher Suites</a></h1>
<p id="rfc.section.D.3.p.1">TLS supports a range of key sizes and security levels, including some that provide no or minimal security. A proper implementation will probably not support many cipher suites. For instance, anonymous Diffie-Hellman is strongly discouraged because it cannot prevent man- in-the-middle attacks. Applications should also enforce minimum and maximum key sizes. For example, certificate chains containing 512- bit RSA keys or signatures are not appropriate for high-security applications.</p>
<h1 id="rfc.appendix.D.4"><a href="#rfc.appendix.D.4">D.4.</a> <a href="#implementation-pitfalls" id="implementation-pitfalls">Implementation Pitfalls</a></h1>
<p id="rfc.section.D.4.p.1">Implementation experience has shown that certain parts of earlier TLS specifications are not easy to understand, and have been a source of interoperability and security problems. Many of these areas have been clarified in this document, but this appendix contains a short list of the most important things that require special attention from implementors.</p>
<p id="rfc.section.D.4.p.2">TLS protocol issues:</p>
<p/>

<ul>
  <li>Do you correctly handle handshake messages that are fragmented to multiple TLS records (see <a href="#fragmentation">Section 6.2.1</a>)? Including corner cases like a ClientHello that is split to several small fragments? Do you fragment handshake messages that exceed the maximum fragment size? In particular, the certificate and certificate request handshake messages can be large enough to require fragmentation.</li>
  <li>Do you ignore the TLS record layer version number in all TLS records before ServerHello (see <a href="#compatibility">Appendix E.1</a>)?</li>
  <li>Do you handle TLS extensions in ClientHello correctly, including omitting the extensions field completely?</li>
  <li>When the server has requested a client certificate, but no suitable certificate is available, do you correctly send an empty Certificate message, instead of omitting the whole message (see <a href="#client-certificate">Section 7.3.9</a>)?</li>
</ul>
<p id="rfc.section.D.4.p.4">Cryptographic details:</p>
<p/>

<ul>
  <li>What countermeasures do you use to prevent timing attacks against RSA signing operations <a href="#TIMING">[TIMING]</a>.</li>
  <li>When verifying RSA signatures, do you accept both NULL and missing parameters (see <a href="#cryptographic-attributes">Section 4.7</a>)? Do you verify that the RSA padding doesn&#8217;t have additional data after the hash value? <a href="#FI06">[FI06]</a></li>
  <li>When using Diffie-Hellman key exchange, do you correctly strip leading zero bytes from the negotiated key (see <a href="#diffie-hellman">Section 8.1.2</a>)?</li>
  <li>Does your TLS client check that the Diffie-Hellman parameters sent by the server are acceptable (see <a href="#diffie-hellman-key-exchange-with-authentication">Appendix F.1.1.2</a>)?</li>
  <li>Do you use a strong and, most importantly, properly seeded random number generator (see <a href="#random-number-generation-and-seeding">Appendix D.1</a>) Diffie-Hellman private values, the DSA &#8220;k&#8221; parameter, and other security-critical values?</li>
</ul>
<h1 id="rfc.appendix.E"><a href="#rfc.appendix.E">Appendix E.</a> <a href="#backward-compatibility" id="backward-compatibility">Backward Compatibility</a></h1>
<h1 id="rfc.appendix.E.1"><a href="#rfc.appendix.E.1">E.1.</a> <a href="#compatibility" id="compatibility">Compatibility with prior versions</a></h1>
<p id="rfc.section.E.1.p.1">[[TODO: Revise backward compatibility section for TLS 1.3.  https://github.com/tlswg/tls13-spec/issues/54]] Since there are various versions of TLS (1.0, 1.1, 1.2, 1.3, and any future versions) and SSL (2.0 and 3.0), means are needed to negotiate the specific protocol version to use. The TLS protocol provides a built-in mechanism for version negotiation so as not to bother other protocol components with the complexities of version selection.</p>
<p id="rfc.section.E.1.p.2">TLS versions 1.0, 1.1, and 1.2, and SSL 3.0 are very similar, and use compatible ClientHello messages; thus, supporting all of them is relatively easy. Similarly, servers can easily handle clients trying to use future versions of TLS as long as the ClientHello format remains compatible, and the client supports the highest protocol version available in the server.</p>
<p id="rfc.section.E.1.p.3">A TLS 1.3 client who wishes to negotiate with such older servers will send a normal TLS 1.3 ClientHello, containing { 3, 4 } (TLS 1.3) in ClientHello.client_version. If the server does not support this version, it will respond with a ServerHello containing an older version number. If the client agrees to use this version, the negotiation will proceed as appropriate for the negotiated protocol.</p>
<p id="rfc.section.E.1.p.4">If the version chosen by the server is not supported by the client (or not acceptable), the client MUST send a &#8220;protocol_version&#8221; alert message and close the connection.</p>
<p id="rfc.section.E.1.p.5">If a TLS server receives a ClientHello containing a version number greater than the highest version supported by the server, it MUST reply according to the highest version supported by the server.</p>
<p id="rfc.section.E.1.p.6">A TLS server can also receive a ClientHello containing a version number smaller than the highest supported version. If the server wishes to negotiate with old clients, it will proceed as appropriate for the highest version supported by the server that is not greater than ClientHello.client_version. For example, if the server supports TLS 1.0, 1.1, and 1.2, and client_version is TLS 1.0, the server will proceed with a TLS 1.0 ServerHello. If server supports (or is willing to use) only versions greater than client_version, it MUST send a &#8220;protocol_version&#8221; alert message and close the connection.</p>
<p id="rfc.section.E.1.p.7">Whenever a client already knows the highest protocol version known to a server (for example, when resuming a session), it SHOULD initiate the connection in that native protocol.</p>
<p id="rfc.section.E.1.p.8">Note: some server implementations are known to implement version negotiation incorrectly. For example, there are buggy TLS 1.0 servers that simply close the connection when the client offers a version newer than TLS 1.0. Also, it is known that some servers will refuse the connection if any TLS extensions are included in ClientHello. Interoperability with such buggy servers is a complex topic beyond the scope of this document, and may require multiple connection attempts by the client.</p>
<p id="rfc.section.E.1.p.9">Earlier versions of the TLS specification were not fully clear on what the record layer version number (TLSPlaintext.version) should contain when sending ClientHello (i.e., before it is known which version of the protocol will be employed). Thus, TLS servers compliant with this specification MUST accept any value {03,XX} as the record layer version number for ClientHello.</p>
<p id="rfc.section.E.1.p.10">TLS clients that wish to negotiate with older servers MAY send any value {03,XX} as the record layer version number. Typical values would be {03,00}, the lowest version number supported by the client, and the value of ClientHello.client_version. No single value will guarantee interoperability with all old servers, but this is a complex topic beyond the scope of this document.</p>
<h1 id="rfc.appendix.E.2"><a href="#rfc.appendix.E.2">E.2.</a> <a href="#compatibility-with-ssl" id="compatibility-with-ssl">Compatibility with SSL</a></h1>
<p id="rfc.section.E.2.p.1">The security of SSL 2.0 <a href="#SSL2">[SSL2]</a> is considered insufficient for the reasons enumerated in <a href="#RFC6176">[RFC6176]</a>, and MUST NOT be negotiated for any reason.</p>
<p id="rfc.section.E.2.p.2">Implementations MUST NOT send an SSL version 2.0 compatible CLIENT-HELLO.  Implementations MUST NOT negotiate TLS 1.3 or later using an SSL version 2.0 compatible CLIENT-HELLO. Implementations are NOT RECOMMENDED to accept an SSL version 2.0 compatible CLIENT-HELLO in order to negotiate older versions of TLS.</p>
<p id="rfc.section.E.2.p.3">Implementations MUST NOT send or accept any records with a version less than { 3, 0 }.</p>
<p id="rfc.section.E.2.p.4">The security of SSL 3.0 <a href="#SSL3">[SSL3]</a> is considered insufficient for the reasons enumerated in <a href="#I-D.ietf-tls-sslv3-diediedie">[I-D.ietf-tls-sslv3-diediedie]</a>, and MUST NOT be negotiated for any reason.</p>
<p id="rfc.section.E.2.p.5">Implementations MUST NOT send a ClientHello.version or ServerHello.version set to { 3, 0 } or less. Any endpoint receiving a Hello message with ClientHello.version or ServerHello.version set to { 3, 0 } MUST respond with a &#8220;protocol_version&#8221; alert message and close the connection.</p>
<h1 id="rfc.appendix.F"><a href="#rfc.appendix.F">Appendix F.</a> <a href="#security-analysis" id="security-analysis">Security Analysis</a></h1>
<p id="rfc.section.F.p.1">The TLS protocol is designed to establish a secure connection between a client and a server communicating over an insecure channel. This document makes several traditional assumptions, including that attackers have substantial computational resources and cannot obtain secret information from sources outside the protocol. Attackers are assumed to have the ability to capture, modify, delete, replay, and otherwise tamper with messages sent over the communication channel. This appendix outlines how TLS has been designed to resist a variety of attacks.</p>
<h1 id="rfc.appendix.F.1"><a href="#rfc.appendix.F.1">F.1.</a> <a href="#handshake-protocol-2" id="handshake-protocol-2">Handshake Protocol</a></h1>
<p id="rfc.section.F.1.p.1">The handshake protocol is responsible for selecting a cipher spec and generating a master secret, which together comprise the primary cryptographic parameters associated with a secure session. The handshake protocol can also optionally authenticate parties who have certificates signed by a trusted certificate authority.</p>
<h1 id="rfc.appendix.F.1.1"><a href="#rfc.appendix.F.1.1">F.1.1.</a> <a href="#authentication-and-key-exchange" id="authentication-and-key-exchange">Authentication and Key Exchange</a></h1>
<p id="rfc.section.F.1.1.p.1">TLS supports three authentication modes: authentication of both parties, server authentication with an unauthenticated client, and total anonymity. Whenever the server is authenticated, the channel is secure against man-in-the-middle attacks, but completely anonymous sessions are inherently vulnerable to such attacks. Anonymous servers cannot authenticate clients. If the server is authenticated, its certificate message must provide a valid certificate chain leading to an acceptable certificate authority. Similarly, authenticated clients must supply an acceptable certificate to the server. Each party is responsible for verifying that the other&#8217;s certificate is valid and has not expired or been revoked.</p>
<p id="rfc.section.F.1.1.p.2">The general goal of the key exchange process is to create a pre_master_secret known to the communicating parties and not to attackers. The pre_master_secret will be used to generate the master_secret (see <a href="#computing-the-master-secret">Section 8.1</a>). The master_secret is required to generate the Finished messages and record protection keys (see <a href="#server-finished">Section 7.3.8</a> and <a href="#key-calculation">Section 6.3</a>). By sending a correct Finished message, parties thus prove that they know the correct pre_master_secret.</p>
<h1 id="rfc.appendix.F.1.1.1"><a href="#rfc.appendix.F.1.1.1">F.1.1.1.</a> <a href="#anonymous-key-exchange" id="anonymous-key-exchange">Anonymous Key Exchange</a></h1>
<p id="rfc.section.F.1.1.1.p.1">Completely anonymous sessions can be established using Diffie-Hellman for key exchange. The server&#8217;s public parameters are contained in the server key share message, and the client&#8217;s are sent in the client key share message.  Eavesdroppers who do not know the private values should not be able to find the Diffie-Hellman result (i.e., the pre_master_secret).</p>
<p id="rfc.section.F.1.1.1.p.2">Warning: Completely anonymous connections only provide protection against passive eavesdropping. Unless an independent tamper-proof channel is used to verify that the Finished messages were not replaced by an attacker, server authentication is required in environments where active man-in-the-middle attacks are a concern.</p>
<h1 id="rfc.appendix.F.1.1.2"><a href="#rfc.appendix.F.1.1.2">F.1.1.2.</a> <a href="#diffie-hellman-key-exchange-with-authentication" id="diffie-hellman-key-exchange-with-authentication">Diffie-Hellman Key Exchange with Authentication</a></h1>
<p id="rfc.section.F.1.1.2.p.1">When Diffie-Hellman key exchange is used, the client and server use the client key exchange and server key exchange messages to send temporary Diffie-Hellman parameters. The signature in the certificate verify message (if present) covers the entire handshake up to that point and thus attests the certificate holder&#8217;s desire to use the the ephemeral DHE keys.</p>
<p id="rfc.section.F.1.1.2.p.2">Peers SHOULD validate each other&#8217;s public key Y (dh_Ys offered by the server or DH_Yc offered by the client) by ensuring that 1 &lt; Y &lt; p-1.  This simple check ensures that the remote peer is properly behaved and isn&#8217;t forcing the local system into a small subgroup.</p>
<p id="rfc.section.F.1.1.2.p.3">Additionally, using a fresh key for each handshake provides Perfect Forward Secrecy. Implementations SHOULD generate a new X for each handshake when using DHE cipher suites.</p>
<h1 id="rfc.appendix.F.1.2"><a href="#rfc.appendix.F.1.2">F.1.2.</a> <a href="#version-rollback-attacks" id="version-rollback-attacks">Version Rollback Attacks</a></h1>
<p id="rfc.section.F.1.2.p.1">Because TLS includes substantial improvements over SSL Version 2.0, attackers may try to make TLS-capable clients and servers fall back to Version 2.0. This attack can occur if (and only if) two TLS- capable parties use an SSL 2.0 handshake.</p>
<p id="rfc.section.F.1.2.p.2">Although the solution using non-random PKCS #1 block type 2 message padding is inelegant, it provides a reasonably secure way for Version 3.0 servers to detect the attack. This solution is not secure against attackers who can brute-force the key and substitute a new ENCRYPTED-KEY-DATA message containing the same key (but with normal padding) before the application-specified wait threshold has expired. Altering the padding of the least-significant 8 bytes of the PKCS padding does not impact security for the size of the signed hashes and RSA key lengths used in the protocol, since this is essentially equivalent to increasing the input block size by 8 bytes.</p>
<h1 id="rfc.appendix.F.1.3"><a href="#rfc.appendix.F.1.3">F.1.3.</a> <a href="#detecting-attacks-against-the-handshake-protocol" id="detecting-attacks-against-the-handshake-protocol">Detecting Attacks Against the Handshake Protocol</a></h1>
<p id="rfc.section.F.1.3.p.1">An attacker might try to influence the handshake exchange to make the parties select different encryption algorithms than they would normally choose.</p>
<p id="rfc.section.F.1.3.p.2">For this attack, an attacker must actively change one or more handshake messages. If this occurs, the client and server will compute different values for the handshake message hashes. As a result, the parties will not accept each others&#8217; Finished messages. Without the master_secret, the attacker cannot repair the Finished messages, so the attack will be discovered.</p>
<h1 id="rfc.appendix.F.1.4"><a href="#rfc.appendix.F.1.4">F.1.4.</a> <a href="#resuming-sessions" id="resuming-sessions">Resuming Sessions</a></h1>
<p id="rfc.section.F.1.4.p.1">When a connection is established by resuming a session, new ClientHello.random and ServerHello.random values are hashed with the session&#8217;s master_secret.  Provided that the master_secret has not been compromised and that the secure hash operations used to produce the record protection kayes are secure, the connection should be secure and effectively independent from previous connections. Attackers cannot use known keys to compromise the master_secret without breaking the secure hash operations.</p>
<p id="rfc.section.F.1.4.p.2">Sessions cannot be resumed unless both the client and server agree. If either party suspects that the session may have been compromised, or that certificates may have expired or been revoked, it should force a full handshake. An upper limit of 24 hours is suggested for session ID lifetimes, since an attacker who obtains a master_secret may be able to impersonate the compromised party until the corresponding session ID is retired. Applications that may be run in relatively insecure environments should not write session IDs to stable storage.</p>
<h1 id="rfc.appendix.F.2"><a href="#rfc.appendix.F.2">F.2.</a> <a href="#protecting-application-data" id="protecting-application-data">Protecting Application Data</a></h1>
<p id="rfc.section.F.2.p.1">The master_secret is hashed with the ClientHello.random and ServerHello.random to produce unique record protection secrets for each connection.</p>
<p id="rfc.section.F.2.p.2">Outgoing data is protected using an AEAD algorithm before transmission. The authentication data includes the sequence number, message type, message length, and the message contents. The message type field is necessary to ensure that messages intended for one TLS record layer client are not redirected to another. The sequence number ensures that attempts to delete or reorder messages will be detected. Since sequence numbers are 64 bits long, they should never overflow.  Messages from one party cannot be inserted into the other&#8217;s output, since they use independent keys.</p>
<h1 id="rfc.appendix.F.3"><a href="#rfc.appendix.F.3">F.3.</a> <a href="#denial-of-service" id="denial-of-service">Denial of Service</a></h1>
<p id="rfc.section.F.3.p.1">TLS is susceptible to a number of denial-of-service (DoS) attacks. In particular, an attacker who initiates a large number of TCP connections can cause a server to consume large amounts of CPU doing asymmetric crypto operations. However, because TLS is generally used over TCP, it is difficult for the attacker to hide his point of origin if proper TCP SYN randomization is used <a href="#RFC1948">[RFC1948]</a> by the TCP stack.</p>
<p id="rfc.section.F.3.p.2">Because TLS runs over TCP, it is also susceptible to a number of DoS attacks on individual connections. In particular, attackers can forge RSTs, thereby terminating connections, or forge partial TLS records, thereby causing the connection to stall. These attacks cannot in general be defended against by a TCP-using protocol. Implementors or users who are concerned with this class of attack should use IPsec AH <a href="#RFC4302">[RFC4302]</a> or ESP <a href="#RFC4303">[RFC4303]</a>.</p>
<h1 id="rfc.appendix.F.4"><a href="#rfc.appendix.F.4">F.4.</a> <a href="#final-notes" id="final-notes">Final Notes</a></h1>
<p id="rfc.section.F.4.p.1">For TLS to be able to provide a secure connection, both the client and server systems, keys, and applications must be secure. In addition, the implementation must be free of security errors.</p>
<p id="rfc.section.F.4.p.2">The system is only as strong as the weakest key exchange and authentication algorithm supported, and only trustworthy cryptographic functions should be used. Short public keys and anonymous servers should be used with great caution. Implementations and users must be careful when deciding which certificates and certificate authorities are acceptable; a dishonest certificate authority can do tremendous damage.</p>
<h1 id="rfc.appendix.G"><a href="#rfc.appendix.G">Appendix G.</a> <a href="#working-group-information" id="working-group-information">Working Group Information</a></h1>
<p id="rfc.section.G.p.1">The discussion list for the IETF TLS working group is located at the e-mail address <a href="mailto:tls@ietf.org">tls@ietf.org</a>. Information on the group and information on how to subscribe to the list is at <a href="https://www1.ietf.org/mailman/listinfo/tls">https://www1.ietf.org/mailman/listinfo/tls</a></p>
<p id="rfc.section.G.p.2">Archives of the list can be found at: <a href="http://www.ietf.org/mail-archive/web/tls/current/index.html">http://www.ietf.org/mail-archive/web/tls/current/index.html</a></p>
<h1 id="rfc.appendix.H"><a href="#rfc.appendix.H">Appendix H.</a> <a href="#contributors" id="contributors">Contributors</a></h1>
<pre>
Christopher Allen (co-editor of TLS 1.0)
Alacrity Ventures
ChristopherA@AlacrityManagement.com

Martin Abadi
University of California, Santa Cruz
abadi@cs.ucsc.edu

Karthikeyan Bhargavan (co-author of [I-D.ietf-tls-session-hash])
INRIA
karthikeyan.bhargavan@inria.fr

Steven M. Bellovin
Columbia University
smb@cs.columbia.edu

Simon Blake-Wilson (co-author of RFC4492)
BCI
sblakewilson@bcisse.com

Nelson Bolyard
Sun Microsystems, Inc.
nelson@bolyard.com (co-author of RFC4492)

Ran Canetti
IBM
canetti@watson.ibm.com

Pete Chown
Skygate Technology Ltd
pc@skygate.co.uk

Antoine Delignat-Lavaud (co-author of [I-D.ietf-tls-session-hash])
INRIA
antoine.delignat-lavaud@inria.fr

Tim Dierks (co-editor of TLS 1.0, 1.1, and 1.2)
Independent
tim@dierks.org

Taher Elgamal
taher@securify.com
Securify

Pasi Eronen
pasi.eronen@nokia.com
Nokia

Anil Gangolli
anil@busybuddha.org

Vipul Gupta (co-author of RFC4492)
Sun Microsystems Laboratories
vipul.gupta@sun.com

Kipp Hickman

Chris Hawk (co-author of RFC4492)
Corriente Networks LLC
chris@corriente.net

Alfred Hoenes

David Hopwood
Independent Consultant
david.hopwood@blueyonder.co.uk

Daniel Kahn Gillmor
ACLU
dkg@fifthhorseman.net

Phil Karlton (co-author of SSLv3)

Paul Kocher (co-author of SSLv3)
Cryptography Research
paul@cryptography.com

Hugo Krawczyk
IBM
hugo@ee.technion.ac.il

Adam Langley (co-author of [I-D.ietf-tls-session-hash])
Google
agl@google.com

Ilari Liusvaara 
ilari.liusvaara@elisanet.fi

Jan Mikkelsen
Transactionware
janm@transactionware.com

Bodo Moeller (co-author of RFC4492)
Google
bodo@openssl.org

Magnus Nystrom
RSA Security
magnus@rsasecurity.com

Alfredo Pironti (co-author of [I-D.ietf-tls-session-hash])
INRIA
alfredo.pironti@inria.fr

Marsh Ray (co-author of [I-D.ietf-tls-session-hash])
Microsoft
maray@microsoft.com

Robert Relyea
Netscape Communications
relyea@netscape.com

Jim Roskind
Netscape Communications
jar@netscape.com

Michael Sabin

Dan Simon
Microsoft, Inc.
dansimon@microsoft.com

Martin Thomson
Mozilla
mt@mozilla.com

Tom Weinstein

Tim Wright
Vodafone
timothy.wright@vodafone.com
</pre>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Author's Address</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Eric Rescorla</span> 
	  <span class="n hidden">
		<span class="family-name">Rescorla</span>
	  </span>
	</span>
	<span class="org vcardline">RTFM, Inc.</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ekr@rtfm.com">ekr@rtfm.com</a></span>

  </address>
</div>

</body>
</html>
